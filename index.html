<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Finger Chooser</title>

  <style>
    html, body{
      margin:0;
      height:100%;
      background:black;
      font-family:-apple-system,system-ui,sans-serif;
      overflow:hidden;
      color:white;
    }

    #zone{
      height:100%;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
    }

    #colorFill{
      position:fixed;
      inset:0;
      opacity:0;
      transition: opacity 220ms ease;
      z-index:1;
      pointer-events:none;
    }
    #colorFill.on{ opacity:1; }

    #topbar{
      position:fixed;
      top:12px;
      left:12px;
      right:12px;
      z-index:10;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }

    #state{
      font-size:18px;
      opacity:0.95;
      text-transform: lowercase;
    }

    #controls{
      display:flex;
      align-items:center;
      gap:8px;
      background:rgba(255,255,255,.10);
      padding:10px 12px;
      border-radius:16px;
      backdrop-filter: blur(8px);
    }

    #controls label{
      font-size:14px;
      opacity:0.9;
    }

    #winnerCount{
      appearance:none;
      -webkit-appearance:none;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(0,0,0,.35);
      color:white;
      padding:8px 10px;
      border-radius:12px;
      font-size:14px;
      outline:none;
    }

    .dot{
      position:fixed;
      width:130px;
      height:130px;
      border-radius:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:5;
      box-shadow:0 0 40px rgba(255,255,255,.22);
      opacity:0.95;
      transition:
        opacity 260ms ease,
        transform 260ms ease,
        filter 260ms ease;
    }

    @keyframes pulse{
      0%   { transform:translate(-50%,-50%) scale(0.92); }
      100% { transform:translate(-50%,-50%) scale(1.08); }
    }
    @keyframes jitter{
      0% { margin:0 }
      25% { margin-left:3px }
      50% { margin-top:3px }
      75% { margin-left:-3px }
      100% { margin:0 }
    }
    .dot.running{
      animation:
        pulse 520ms ease-in-out infinite alternate,
        jitter 130ms linear infinite;
    }

    .dot.win{
      outline:8px solid rgba(255,255,255,.95);
      animation:none;
      box-shadow:0 0 90px rgba(255,255,255,.55);
      filter: brightness(1.12) saturate(1.1);
      transform:translate(-50%,-50%) scale(1.12);
      opacity:1;
    }

    .dot.lose{
      animation:none;
      opacity:0;
      transform:translate(-50%,-50%) scale(0.75);
      filter: blur(2px) brightness(0.9);
    }
  </style>
</head>

<body>
  <div id="colorFill"></div>

  <div id="topbar">
    <div id="state">esperando</div>

    <div id="controls">
      <label for="winnerCount">Ganadores</label>
      <select id="winnerCount">
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
      </select>
    </div>
  </div>

  <div id="zone"></div>

<script>
const zone = document.getElementById("zone");
const stateEl = document.getElementById("state");
const winnerCountEl = document.getElementById("winnerCount");
const colorFill = document.getElementById("colorFill");

const MAX = 5;
const ROUND_MS = 4000;
const FILL_MS = 5000;

// Colores vivos (sin blanco/gris/negro)
const COLORS = [
  "#ff3b30", "#ff9500", "#ffcc00", "#34c759", "#00c7be",
  "#007aff", "#5856d6", "#af52de", "#ff2d55", "#ff6f00"
];

const fingers = new Map();   // id -> {x,y,taps,color}
const dotEls  = new Map();   // id -> element

let state = "waiting"; // waiting | running | fin
let timer = null;
let lastCount = 0;

function rand(n){ return Math.floor(Math.random()*n); }
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = rand(i+1);
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

function vibrate(pattern){
  try { if(navigator.vibrate) navigator.vibrate(pattern); } catch(_){}
}

function ensureDot(id){
  let el = dotEls.get(id);
  if(el) return el;
  el = document.createElement("div");
  el.className = "dot";
  document.body.appendChild(el);
  dotEls.set(id, el);
  return el;
}
function removeDot(id){
  const el = dotEls.get(id);
  if(el){ el.remove(); dotEls.delete(id); }
}

/* ✅ Asegura colores NO repetidos entre dedos actuales */
function ensureUniqueColors(){
  // Colores usados por dedos que ya tienen color
  const used = new Set();
  for(const f of fingers.values()){
    if(f.color) used.add(f.color);
  }

  // Lista aleatoria de colores disponibles
  const available = shuffle(COLORS.filter(c => !used.has(c)));

  // Asignar color a los que no tengan (o si su color choca)
  for(const [_, f] of fingers.entries()){
    if(!f.color || usedHasDuplicate(f.color)){
      // si no hay disponibles (raro con <=5), coger cualquiera de COLORS
      const pick = available.length ? available.pop() : COLORS[rand(COLORS.length)];
      // actualizar sets
      if(f.color) used.delete(f.color);
      f.color = pick;
      used.add(pick);
    }
  }

  // Función helper: detecta si un color está duplicado en fingers
  function usedHasDuplicate(color){
    let count = 0;
    for(const ff of fingers.values()){
      if(ff.color === color) count++;
      if(count > 1) return true;
    }
    return false;
  }
}

/* Redibuja (sin recrear todo) */
function renderLive(){
  for(const [id,f] of fingers){
    const el = ensureDot(id);
    el.style.left = f.x + "px";
    el.style.top  = f.y + "px";
    el.style.background = f.color || COLORS[0];

    el.classList.toggle("running", state === "running");
    el.classList.remove("win","lose");
  }
  for(const [id] of dotEls){
    if(!fingers.has(id)) removeDot(id);
  }
}

/* ✅ Reinicia cuenta atrás de 4s */
function restartRoundTimer(){
  if(state !== "running") return;
  clearTimeout(timer);
  timer = setTimeout(endRound, ROUND_MS);
}

/* Empieza la ronda */
function startRound(){
  if(fingers.size < 2) return;

  state = "running";
  stateEl.textContent = "jugando";

  for(const f of fingers.values()) f.taps = 0;

  // Asegura colores únicos al inicio
  ensureUniqueColors();
  renderLive();

  clearTimeout(timer);
  timer = setTimeout(endRound, ROUND_MS);
}

function pickWinners(ids, k){
  const pool = ids.slice();
  const out = [];
  const want = Math.min(k, pool.length);
  for(let i=0;i<want;i++){
    const idx = rand(pool.length);
    out.push(pool[idx]);
    pool.splice(idx,1);
  }
  return out;
}

function setFillFromWinnerColors(colors){
  if(colors.length <= 1){
    colorFill.style.background = colors[0] || "black";
  } else {
    const stops = colors.map((c,i)=>{
      const p = Math.round((i/(colors.length-1))*100);
      return `${c} ${p}%`;
    }).join(", ");
    colorFill.style.background = `linear-gradient(135deg, ${stops})`;
  }
}

function endRound(){
  state = "fin";
  stateEl.textContent = "fin";

  const entries = [...fingers.entries()];
  const wanted = parseInt(winnerCountEl.value || "1", 10);

  const seven = entries.filter(([_,f]) => f.taps === 7).map(([id]) => id);
  const allowed = entries.filter(([_,f]) => f.taps !== 9).map(([id]) => id);

  let winners = [];
  if(seven.length > 0){
    winners = pickWinners(seven, wanted);
    if(winners.length < wanted){
      const rest = allowed.filter(id => !winners.includes(id));
      winners = winners.concat(pickWinners(rest, wanted - winners.length));
    }
  } else {
    if(allowed.length > 0) winners = pickWinners(allowed, wanted);
    else if(entries.length > 0) winners = pickWinners(entries.map(([id])=>id), wanted);
  }

  const winSet = new Set(winners);

  // Vibración “tada”
  vibrate([30, 40, 30, 40, 60]);

  // Ganadores pop, perdedores se van
  for(const [id] of fingers){
    const el = dotEls.get(id);
    if(!el) continue;
    el.classList.remove("running");
    if(winSet.has(id)) el.classList.add("win");
    else el.classList.add("lose");
  }

  // Fondo: color o degradado con colores ganadores
  const winColors = winners.map(id => fingers.get(id)?.color).filter(Boolean);
  setFillFromWinnerColors(winColors);
  colorFill.classList.add("on");

  clearTimeout(timer);
  timer = setTimeout(()=>{
    colorFill.classList.remove("on");

    // eliminar del DOM los no ganadores (ya invisibles)
    for(const [id] of dotEls){
      if(!winSet.has(id)) removeDot(id);
    }

    state = "waiting";
    stateEl.textContent = "esperando";

    // limpiar clases de los que queden
    for(const [id] of fingers){
      const el = dotEls.get(id);
      if(el) el.classList.remove("win","lose","running");
    }
    renderLive();
  }, FILL_MS);
}

/* --- Eventos táctiles --- */
zone.addEventListener("touchstart", e=>{
  e.preventDefault();

  let changedFingerCount = false;

  for(const t of e.changedTouches){
    const id = t.identifier;

    // admitir dedo nuevo si hay hueco
    if(!fingers.has(id) && fingers.size < MAX){
      fingers.set(id, { x:t.clientX, y:t.clientY, taps:0, color:null });
      changedFingerCount = true;
    }

    // actualizar posición si está admitido
    const f = fingers.get(id);
    if(f){
      f.x = t.clientX;
      f.y = t.clientY;
      if(state === "running") f.taps++;
    }
  }

  // ✅ Colores únicos siempre que entra alguien
  if(changedFingerCount){
    ensureUniqueColors();
  }

  // ✅ Si estamos en running y entró/salió alguien, reinicia 4s
  if(state === "running" && changedFingerCount){
    restartRoundTimer();
  }

  // Empieza cuando pasa de <2 a >=2
  if(state === "waiting" && lastCount < 2 && fingers.size >= 2){
    startRound();
  }

  lastCount = fingers.size;

  if(state !== "fin") renderLive();
},{passive:false});

zone.addEventListener("touchmove", e=>{
  e.preventDefault();
  if(state === "fin") return;

  for(const t of e.changedTouches){
    const f = fingers.get(t.identifier);
    if(f){ f.x = t.clientX; f.y = t.clientY; }
  }
  renderLive();
},{passive:false});

zone.addEventListener("touchend", e=>{
  e.preventDefault();

  let changedFingerCount = false;

  for(const t of e.changedTouches){
    if(fingers.has(t.identifier)){
      fingers.delete(t.identifier);
      removeDot(t.identifier);
      changedFingerCount = true;
    }
  }

  lastCount = fingers.size;

  // ✅ Si estamos en running y alguien se fue, reinicia 4s
  if(state === "running" && changedFingerCount){
    // también asegurar que no quedaron colores duplicados (por si acaso)
    ensureUniqueColors();
    restartRoundTimer();
  }
},{passive:false});

zone.addEventListener("touchcancel", e=>{
  e.preventDefault();

  let changedFingerCount = false;

  for(const t of e.changedTouches){
    if(fingers.has(t.identifier)){
      fingers.delete(t.identifier);
      removeDot(t.identifier);
      changedFingerCount = true;
    }
  }

  lastCount = fingers.size;

  if(state === "running" && changedFingerCount){
    ensureUniqueColors();
    restartRoundTimer();
  }
},{passive:false});

stateEl.textContent = "esperando";
ensureUniqueColors();
renderLive();
</script>
</body>
</html>

</body>
</html>
