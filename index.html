<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Finger Chooser</title>

  <style>
    html, body{
      margin:0;
      height:100%;
      background:black;
      font-family:-apple-system,system-ui,sans-serif;
      overflow:hidden;
      color:white;
    }

    #zone{
      height:100%;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
    }

    /* Capa de fondo de color al final */
    #colorFill{
      position:fixed;
      inset:0;
      background:transparent;
      opacity:0;
      transition: opacity 180ms ease;
      z-index:1;
      pointer-events:none;
    }
    #colorFill.on{
      opacity:1;
    }

    #topbar{
      position:fixed;
      top:12px;
      left:12px;
      right:12px;
      z-index:10;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }

    #state{
      font-size:18px;
      opacity:0.95;
      text-transform: lowercase;
    }

    #controls{
      display:flex;
      align-items:center;
      gap:8px;
      background:rgba(255,255,255,.10);
      padding:10px 12px;
      border-radius:16px;
      backdrop-filter: blur(8px);
    }

    #controls label{
      font-size:14px;
      opacity:0.9;
    }

    #winnerCount{
      appearance:none;
      -webkit-appearance:none;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(0,0,0,.35);
      color:white;
      padding:8px 10px;
      border-radius:12px;
      font-size:14px;
      outline:none;
    }

    .dot{
      position:fixed;
      width:130px;
      height:130px;
      border-radius:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
      box-shadow:0 0 40px rgba(255,255,255,.25);
      z-index:5;
      transition: opacity 160ms ease, transform 160ms ease;
      opacity: 0.95;
    }

    @keyframes pulse{
      0%   { transform:translate(-50%,-50%) scale(0.92); }
      100% { transform:translate(-50%,-50%) scale(1.08); }
    }
    @keyframes jitter{
      0% { margin:0 }
      25% { margin-left:3px }
      50% { margin-top:3px }
      75% { margin-left:-3px }
      100% { margin:0 }
    }
    .dot.running{
      animation:
        pulse 520ms ease-in-out infinite alternate,
        jitter 130ms linear infinite;
    }

    .dot.win{
      outline:8px solid white;
      animation:none;
      box-shadow:0 0 70px rgba(255,255,255,.6);
      opacity:1;
    }

    .dot.dim{
      opacity:0;
      transform:translate(-50%,-50%) scale(0.7);
      animation:none;
    }
  </style>
</head>

<body>
  <div id="colorFill"></div>

  <div id="topbar">
    <div id="state">esperando</div>

    <div id="controls">
      <label for="winnerCount">Ganadores</label>
      <select id="winnerCount">
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
      </select>
    </div>
  </div>

  <div id="zone"></div>

<script>
const zone = document.getElementById("zone");
const stateEl = document.getElementById("state");
const winnerCountEl = document.getElementById("winnerCount");
const colorFill = document.getElementById("colorFill");

const MAX = 5;
const ROUND = 4000;
const FILL_MS = 5000;

const COLORS = [
  "#ff3b30", "#ff9500", "#ffcc00", "#34c759", "#00c7be",
  "#007aff", "#5856d6", "#af52de", "#ff2d55", "#ff6f00"
];

const fingers = new Map(); // id -> {x,y,taps,color}
let state = "waiting";
let timer = null;
let lastCount = 0;

function randomIndex(n){ return Math.floor(Math.random()*n); }

function shuffled(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = randomIndex(i+1);
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* Vibración (iPhone: funciona en algunos casos; si no, no pasa nada) */
function vibrate(pattern){
  try{
    if (navigator.vibrate) navigator.vibrate(pattern);
  }catch(_){}
}

function assignUniqueColors(){
  // Colores únicos para todos los dedos actuales (<=5)
  const colors = shuffled(COLORS);
  const ids = [...fingers.keys()];
  for(let i=0;i<ids.length;i++){
    fingers.get(ids[i]).color = colors[i]; // único
  }
}

function render(winSet=null, hideNonWinners=false){
  document.querySelectorAll(".dot").forEach(d=>d.remove());

  for(const [id,f] of fingers){
    // Si al final queremos esconder no-ganadores, no los dibujamos
    if(hideNonWinners && winSet && !winSet.has(id)) continue;

    const d = document.createElement("div");
    d.className = "dot";

    if(state==="running") d.classList.add("running");

    if(winSet){
      if(winSet.has(id)) d.classList.add("win");
      else d.classList.add("dim"); // si no se ocultan, se apagan (pero aquí luego los ocultamos)
    }

    d.style.left = f.x + "px";
    d.style.top  = f.y + "px";
    d.style.background = f.color;

    document.body.appendChild(d);
  }
}

function start(){
  if(fingers.size < 2) return;

  state="running";
  stateEl.textContent="jugando";

  // reset taps y asignar colores únicos (sin repetir)
  for(const f of fingers.values()) f.taps = 0;
  assignUniqueColors();

  render(null,false);
  clearTimeout(timer);
  timer = setTimeout(end, ROUND);
}

function pickWinners(ids, k){
  const pool = ids.slice();
  const out = [];
  const want = Math.min(k, pool.length);
  for(let i=0;i<want;i++){
    const idx = randomIndex(pool.length);
    out.push(pool[idx]);
    pool.splice(idx,1);
  }
  return out;
}

function end(){
  state="fin";
  stateEl.textContent="fin";

  const entries = [...fingers.entries()];
  const wanted = parseInt(winnerCountEl.value || "1", 10);

  const seven = entries.filter(([_,f]) => f.taps === 7).map(([id]) => id);
  const allowed = entries.filter(([_,f]) => f.taps !== 9).map(([id]) => id);

  let winners = [];

  if(seven.length > 0){
    winners = pickWinners(seven, wanted);
    if(winners.length < wanted){
      const rest = allowed.filter(id => !winners.includes(id));
      winners = winners.concat(pickWinners(rest, wanted - winners.length));
    }
  } else {
    if(allowed.length > 0){
      winners = pickWinners(allowed, wanted);
    } else if(entries.length > 0){
      winners = pickWinners(entries.map(([id])=>id), wanted);
    }
  }

  const winSet = new Set(winners);

  // 1) Vibración al decidir
  vibrate([60, 40, 60]);

  // 2) Mostrar SOLO ganadores (no ganadores desaparecen)
  render(winSet, true);

  // 3) Fondo se cubre con el color del primer ganador (si hay)
  let fillColor = "#000000";
  if(winners.length > 0 && fingers.has(winners[0])){
    fillColor = fingers.get(winners[0]).color;
  }
  colorFill.style.background = fillColor;
  colorFill.classList.add("on");

  // 4) Mantener 5 segundos y volver a esperar
  clearTimeout(timer);
  timer = setTimeout(()=>{
    colorFill.classList.remove("on");
    state="waiting";
    stateEl.textContent="esperando";
    render(null,false);
  }, FILL_MS);
}

// Tap = touchstart durante la ronda
zone.addEventListener("touchstart", e=>{
  e.preventDefault();

  for(const t of e.changedTouches){
    const id = t.identifier;

    // admitir dedo nuevo si hay hueco
    if(!fingers.has(id) && fingers.size < MAX){
      fingers.set(id, { x:t.clientX, y:t.clientY, taps:0, color: COLORS[0] });
    }

    // cuenta tap solo si está admitido
    if(state === "running" && fingers.has(id)){
      fingers.get(id).taps++;
    }

    // actualiza posición si está admitido
    if(fingers.has(id)){
      const f = fingers.get(id);
      f.x = t.clientX;
      f.y = t.clientY;
    }
  }

  // Arranca cuando pasa de <2 a >=2 dedos admitidos
  if(state === "waiting" && lastCount < 2 && fingers.size >= 2){
    start();
  }

  lastCount = fingers.size;

  // durante fin, no redibujar todo (para que no reaparezcan no-ganadores)
  if(state !== "fin") render(null,false);
},{passive:false});

zone.addEventListener("touchmove", e=>{
  e.preventDefault();
  if(state === "fin") return;
  for(const t of e.changedTouches){
    const f = fingers.get(t.identifier);
    if(f){ f.x = t.clientX; f.y = t.clientY; }
  }
  render(null,false);
},{passive:false});

zone.addEventListener("touchend", e=>{
  e.preventDefault();

  // durante fin, dejamos los ganadores visibles y el fondo cubierto
  for(const t of e.changedTouches){
    fingers.delete(t.identifier);
  }
  lastCount = fingers.size;

  if(state !== "fin") render(null,false);
},{passive:false});

zone.addEventListener("touchcancel", e=>{
  e.preventDefault();
  for(const t of e.changedTouches){
    fingers.delete(t.identifier);
  }
  lastCount = fingers.size;
  if(state !== "fin") render(null,false);
},{passive:false});

stateEl.textContent = "esperando";
render(null,false);
</script>
</body>
</html>
