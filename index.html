<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Finger Chooser</title>

<style>
:root{ --green:#7fb13a; --orange:#ff8a00; }
html,body{ margin:0;height:100%;background:#000;overflow:hidden;font-family:-apple-system,system-ui,sans-serif; }
#zone{ height:100%; touch-action:none; user-select:none; -webkit-user-select:none; }

#topbar{
  position:fixed;top:12px;left:12px;right:12px;z-index:10;
  display:flex;justify-content:space-between;align-items:flex-start;gap:12px;
}
#winBtn{
  width:76px;height:76px;border-radius:50%;
  background:var(--green);
  display:flex;align-items:center;justify-content:center;
  color:#fff;font-size:34px;font-weight:500;
  border:none;outline:none;
  box-shadow:0 6px 18px rgba(0,0,0,.35);
  -webkit-tap-highlight-color:transparent;
}
#helpBtn{
  width:76px;height:76px;border-radius:50%;
  background:#ff00a8;
  display:flex;align-items:center;justify-content:center;
  color:#fff;font-size:44px;font-weight:500;
  border:none;outline:none;
  box-shadow:0 6px 18px rgba(0,0,0,.35);
  -webkit-tap-highlight-color:transparent;
}

/* texto “secreto” abajo derecha + estado arriba (mismo color siempre) */
#hint{
  position:fixed;right:10px;bottom:10px;font-size:11px;
  color:#000;opacity:.6;z-index:20;user-select:none;pointer-events:none;
}
#state{
  position:fixed;left:50%;top:16px;transform:translateX(-50%);
  font-size:13px;opacity:.55;text-transform:lowercase;z-index:10;
  color:#000;pointer-events:none;
}

/* Modal */
#modalOverlay{
  position:fixed;inset:0;z-index:50;
  display:none;align-items:center;justify-content:center;
  background:rgba(0,0,0,.15);
}
#modalOverlay.on{display:flex;}
#modal{
  width:min(340px,86vw);
  background:#fff;border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.35);
  padding:16px 16px 14px;color:#1a1a1a;
}
#row{ display:flex;align-items:center;justify-content:space-between;padding:4px 6px 14px; }
.stepBtn{
  width:54px;height:54px;border-radius:50%;
  border:3px solid var(--accent);
  background:#fff;color:var(--accent);
  font-size:34px;line-height:0;
  display:flex;align-items:center;justify-content:center;
  -webkit-tap-highlight-color:transparent;
}
#count{ font-size:44px;font-weight:500;color:#4a4a4a; }
#seg{
  width:100%;
  border:2px solid var(--accent);
  border-radius:14px;overflow:hidden;display:flex;
}
.segBtn{
  flex:1;padding:10px 0;font-size:18px;
  border:none;outline:none;background:#fff;color:var(--accent);
}
.segBtn.active{ background:var(--accent); color:#fff; }

/* =========================
   DOT + AROS (animación 4s)
   ========================= */
.dot{
  --c:#ff3b30;
  position:fixed;
  width:130px;height:130px;border-radius:50%;
  transform:translate(-50%,-50%);
  pointer-events:none;
  z-index:5;
  background:var(--c);
  box-shadow:0 0 36px rgba(255,255,255,.14);
  transition:opacity .28s, transform .28s, filter .28s;
}

/* ARO exterior */
.dot::before{
  content:"";
  position:absolute; inset:-16px;border-radius:50%;
  background:conic-gradient(
    from 0deg,
    var(--c) 0 70deg,
    transparent 70deg 175deg,
    var(--c) 175deg 255deg,
    transparent 255deg 360deg
  );
  -webkit-mask:radial-gradient(circle,transparent 60%,#000 61%);
  mask:radial-gradient(circle,transparent 60%,#000 61%);
  opacity:.92;
  transform:rotate(0deg);
}

/* ARO interior */
.dot::after{
  content:"";
  position:absolute; inset:-8px;border-radius:50%;
  background:conic-gradient(
    from 25deg,
    transparent 0 45deg,
    var(--c) 45deg 100deg,
    transparent 100deg 220deg,
    var(--c) 220deg 270deg,
    transparent 270deg 360deg
  );
  -webkit-mask:radial-gradient(circle,transparent 68%,#000 69%);
  mask:radial-gradient(circle,transparent 68%,#000 69%);
  opacity:.62;
  transform:rotate(0deg);
}

/* Animación durante la cuenta (4s) */
.dot.running::before{ animation:ringSpin .65s linear infinite, ringBreathe .9s ease-in-out infinite; }
.dot.running::after { animation:ringSpinReverse .72s linear infinite, ringBreathe2 .95s ease-in-out infinite; }

@keyframes ringSpin{ to{ transform:rotate(360deg); } }
@keyframes ringSpinReverse{ to{ transform:rotate(-360deg); } }
@keyframes ringBreathe{ 0%,100%{ filter:brightness(1); } 50%{ filter:brightness(1.12); } }
@keyframes ringBreathe2{ 0%,100%{ opacity:.45; } 50%{ opacity:.75; } }

/* =========================
   WIN OVERLAY (Fingers) — como tu captura
   ========================= */
#winOverlay{
  position:fixed; inset:0;
  z-index:8; /* por encima de dots (5) y por debajo de topbar (10) */
  display:none;
}
#winOverlay.on{ display:grid; }

.winCell{
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
}
.winDonut{
  --c:#00ff00;
  --bg:#00aa00;
  width:min(260px, 56vw);
  aspect-ratio:1/1;
  border-radius:50%;
  background:#000;
  position:relative;
  filter:drop-shadow(0 10px 30px rgba(0,0,0,.25));
  animation:winPop .22s ease-out forwards;
}

/* aro interior color */
.winDonut::before{
  content:"";
  position:absolute;
  inset:28%;
  border-radius:50%;
  box-shadow: inset 0 0 0 16px var(--c);
  background:transparent;
}

/* centro color + aro negro */
.winDonut::after{
  content:"";
  position:absolute;
  inset:42%;
  border-radius:50%;
  background:var(--bg);
  box-shadow: inset 0 0 0 10px #000;
}

@keyframes winPop{
  0%{ transform:scale(1.18); }
  100%{ transform:scale(1.05); }
}
</style>
</head>

<body>
<div id="winOverlay"></div>

<div id="topbar">
  <button id="winBtn" aria-label="Ganadores">1F</button>
  <button id="helpBtn" aria-label="Ayuda">?</button>
</div>

<div id="state">esperando</div>
<div id="hint">8 gana · W pierde · 7 gana · 9 pierde</div>

<div id="modalOverlay" role="dialog" aria-modal="true">
  <div id="modal">
    <div id="row">
      <button class="stepBtn" id="minus" aria-label="Menos">−</button>
      <div id="count">1</div>
      <button class="stepBtn" id="plus" aria-label="Más">+</button>
    </div>
    <div id="seg">
      <button class="segBtn active" id="segFingers">Fingers</button>
      <button class="segBtn" id="segGroups">Groups</button>
    </div>
  </div>
</div>

<div id="zone"></div>

<script>
(() => {
  const zone = document.getElementById("zone");
  const hintEl = document.getElementById("hint");
  const stateEl = document.getElementById("state");
  const winOverlay = document.getElementById("winOverlay");

  // UI modal
  const winBtn = document.getElementById("winBtn");
  const helpBtn = document.getElementById("helpBtn");
  const overlay = document.getElementById("modalOverlay");
  const minusBtn = document.getElementById("minus");
  const plusBtn = document.getElementById("plus");
  const countEl = document.getElementById("count");
  const segFingers = document.getElementById("segFingers");
  const segGroups = document.getElementById("segGroups");
  const modal = document.getElementById("modal");

  const MAX = 5;
  const ROUND_MS = 4000;
  const SHOW_MS = 5000;

  const COLORS = ["#ff3b30","#ff9500","#ffcc00","#34c759","#00c7be","#007aff","#5856d6","#af52de","#ff2d55","#ff6f00"];

  let selectorValue = 1;      // Fingers: nº ganadores (1–4). Groups: nº grupos (1–4)
  let mode = "fingers";       // fingers | groups

  // id -> {x,y,realColor,groupColor,taps,path,eightLocked,wLocked}
  const fingers = new Map();
  const dots = new Map();

  // estados: waiting | running | winnerFreeze | groupsReveal
  let state = "waiting";
  let timer = null;
  let lastCount = 0;

  const rand = n => Math.floor(Math.random()*n);
  const shuffle = a => { a=a.slice(); for(let i=a.length-1;i;i--){ const j=rand(i+1); [a[i],a[j]]=[a[j],a[i]]; } return a; };

  function setAccent(){
    const accent = (mode==="groups")
      ? getComputedStyle(document.documentElement).getPropertyValue("--orange").trim()
      : getComputedStyle(document.documentElement).getPropertyValue("--green").trim();
    modal.style.setProperty("--accent", accent);
    winBtn.style.background = (mode==="groups") ? "var(--orange)" : "var(--green)";
  }

  function setHiddenTextColor(color){
    hintEl.style.color = color;
    stateEl.style.color = color;
  }

  function ensureDot(id){
    if(dots.has(id)) return dots.get(id);
    const d = document.createElement("div");
    d.className = "dot";
    document.body.appendChild(d);
    dots.set(id,d);
    return d;
  }
  function removeDot(id){
    if(dots.has(id)){
      dots.get(id).remove();
      dots.delete(id);
    }
  }

  // Colores reales únicos (solo “realColor”; en Groups se ocultan hasta reveal)
  function ensureUniqueRealColors(){
    const used = new Set();
    for(const f of fingers.values()) if(f.realColor) used.add(f.realColor);
    const available = shuffle(COLORS.filter(c => !used.has(c)));
    for(const f of fingers.values()){
      if(!f.realColor){
        f.realColor = available.length ? available.pop() : COLORS[rand(COLORS.length)];
        used.add(f.realColor);
      }
    }
  }

  function renderLive(){
    // Victory overlay en Fingers: no dots
    if(state === "winnerFreeze"){
      for(const [id] of dots) removeDot(id);
      return;
    }

    for(const [id,f] of fingers){
      const el = ensureDot(id);
      el.style.left = f.x+"px";
      el.style.top  = f.y+"px";

      let visible = f.realColor || COLORS[0];

      // ✅ SOLO EN GROUPS: durante la cuenta, TODO BLANCO
      if(mode === "groups" && state === "running"){
        visible = "#e8e8e8"; // blanco suave como tu captura
      }

      // ✅ SOLO EN GROUPS: tras el tiempo, colores por grupo
      if(mode === "groups" && state === "groupsReveal"){
        visible = f.groupColor || "#e8e8e8";
      }

      el.style.setProperty("--c", visible);
      el.style.background = visible;

      el.classList.toggle("running", state==="running");
    }

    for(const [id] of dots){
      if(!fingers.has(id)) removeDot(id);
    }
  }

  function restartRoundTimer(){
    if(state!=="running") return;
    clearTimeout(timer);
    timer = setTimeout(endRound, ROUND_MS);
  }

  function startRound(){
    if(fingers.size < 2) return;

    state = "running";
    stateEl.textContent = "jugando";

    for(const f of fingers.values()){
      f.taps = 0;
      f.path = [];
      f.eightLocked = false;
      f.wLocked = false;
      f.groupColor = null;
    }

    ensureUniqueRealColors();
    renderLive();

    clearTimeout(timer);
    timer = setTimeout(endRound, ROUND_MS);
  }

  // ===== Trucos (solo afectan a Fingers) =====
  function isEight(path){
    if(path.length < 14) return false;
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of path){ minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x); minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y); }
    const w=maxX-minX, h=maxY-minY, size=Math.max(w,h);
    if(size < 70) return false;

    let turns=0;
    for(let i=2;i<path.length;i++){
      const aY = path[i-2].y - path[i-1].y;
      const bY = path[i-1].y - path[i].y;
      if(aY*bY < 0) turns++;
    }
    if(turns < 6) return false;

    const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
    let crosses=0;
    const r = Math.min(w,h)*0.14;
    for(const p of path){
      if(Math.hypot(p.x-cx,p.y-cy) < r) crosses++;
    }
    return crosses >= 2;
  }

  function isW(path){
    if(path.length < 10) return false;
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of path){ minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x); minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y); }
    const size=Math.max(maxX-minX, maxY-minY);
    if(size < 70) return false;

    let changes=0;
    for(let i=2;i<path.length;i++){
      const a=path[i-2].y - path[i-1].y;
      const b=path[i-1].y - path[i].y;
      if(a*b < 0) changes++;
    }
    return changes >= 3;
  }

  function trackAndLockIfNeeded(f){
    if(!f || f.eightLocked || f.wLocked) return;
    f.path.push({x:f.x,y:f.y});
    if(isEight(f.path)){ f.eightLocked=true; f.wLocked=false; f.path=f.path.slice(-80); return; }
    if(isW(f.path)){ f.wLocked=true; f.eightLocked=false; f.path=f.path.slice(-80); return; }
  }

  function pickWinners(ids,k){
    const pool = ids.slice();
    const out = [];
    const want = Math.min(k, pool.length);
    for(let i=0;i<want;i++){
      const idx = rand(pool.length);
      out.push(pool[idx]);
      pool.splice(idx,1);
    }
    return out;
  }

  // ===== Winner overlay (Fingers) =====
  function showWinOverlay(colors){
    winOverlay.innerHTML = "";
    winOverlay.classList.add("on");

    const n = Math.max(1, Math.min(4, colors.length || 1));
    const cols = (n === 1) ? 1 : (n === 2 ? 2 : 2);
    const rows = (n <= 2) ? 1 : 2;

    winOverlay.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    winOverlay.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

    for(let i=0;i<cols*rows;i++){
      const c = colors[i] || colors[0] || "#000";
      const cell = document.createElement("div");
      cell.className = "winCell";
      cell.style.background = c;

      const donut = document.createElement("div");
      donut.className = "winDonut";
      donut.style.setProperty("--c", c);
      donut.style.setProperty("--bg", c);

      cell.appendChild(donut);
      winOverlay.appendChild(cell);
    }
  }
  function hideWinOverlay(){
    winOverlay.classList.remove("on");
    winOverlay.innerHTML = "";
  }

  // ===== Groups: asignar colores de grupo SOLO al final =====
  function assignGroupColors(groupCount){
    const ids = [...fingers.keys()];
    const g = Math.max(1, Math.min(4, groupCount));
    const groupColors = shuffle(COLORS).slice(0, g);

    // Reparto round-robin (como “grupos” visuales)
    const shuffled = shuffle(ids);
    let gi = 0;
    for(const id of shuffled){
      const f = fingers.get(id);
      if(!f) continue;
      f.groupColor = groupColors[gi];
      gi = (gi + 1) % g;
    }
  }

  function endRound(){
    clearTimeout(timer);

    // ✅ MODO GROUPS: blanco durante 4s, luego colores de grupos, fondo negro (sin overlay)
    if(mode === "groups"){
      state = "groupsReveal";
      stateEl.textContent = "grupos";

      assignGroupColors(selectorValue);
      renderLive();

      timer = setTimeout(() => {
        state = "waiting";
        stateEl.textContent = "esperando";
        // limpia colores de grupo para la siguiente ronda
        for(const f of fingers.values()) f.groupColor = null;
        renderLive();
      }, SHOW_MS);

      return;
    }

    // ✅ MODO FINGERS: igual que lo tenías (winner overlay)
    stateEl.textContent = "fin";

    const entries = [...fingers.entries()];
    const idsAll = entries.map(([id])=>id);

    const eights = entries.filter(([_,f])=>f.eightLocked).map(([id])=>id);
    const sevens = entries.filter(([_,f])=>f.taps===7).map(([id])=>id);
    const banned9 = entries.filter(([_,f])=>f.taps===9).map(([id])=>id);
    const bannedW = entries.filter(([_,f])=>f.wLocked).map(([id])=>id);
    const banned = new Set([...banned9, ...bannedW]);

    let winners = [];
    const wanted = selectorValue;

    if(eights.length) winners = pickWinners(eights, wanted);
    else if(sevens.length) winners = pickWinners(sevens, wanted);
    else{
      const allowed = idsAll.filter(id=>!banned.has(id));
      winners = allowed.length ? pickWinners(allowed, wanted) : pickWinners(idsAll, wanted);
    }

    const colors = winners.map(id => fingers.get(id)?.realColor).filter(Boolean);
    showWinOverlay(colors.length ? colors : ["#000"]);

    setHiddenTextColor(colors[0] || "#000");

    state = "winnerFreeze";
    for(const [id] of dots) removeDot(id);

    timer = setTimeout(() => {
      hideWinOverlay();
      setHiddenTextColor("#000");
      state = "waiting";
      stateEl.textContent = "esperando";
      renderLive();
    }, SHOW_MS);
  }

  // ---- Touch logic (reinicia 4s si entra o sale un dedo) ----
  zone.addEventListener("touchstart", e=>{
    e.preventDefault();
    if(state==="winnerFreeze" || state==="groupsReveal") return;

    let changed=false;

    for(const t of e.changedTouches){
      const id = t.identifier;

      if(!fingers.has(id) && fingers.size < MAX){
        fingers.set(id,{
          x:t.clientX, y:t.clientY,
          realColor:null, groupColor:null,
          taps:0, path:[],
          eightLocked:false, wLocked:false
        });
        changed=true;
      }

      const f = fingers.get(id);
      if(f){
        f.x=t.clientX; f.y=t.clientY;
        if(state==="running" && mode==="fingers"){ // trucos solo en Fingers
          f.taps++;
          trackAndLockIfNeeded(f);
        }
      }
    }

    if(state==="waiting" && lastCount<2 && fingers.size>=2){
      startRound();
    }

    if(changed && state==="running"){
      ensureUniqueRealColors();
      restartRoundTimer();
    }

    lastCount=fingers.size;

    ensureUniqueRealColors();
    renderLive();
  },{passive:false});

  zone.addEventListener("touchmove", e=>{
    e.preventDefault();
    if(state==="winnerFreeze" || state==="groupsReveal") return;

    for(const t of e.changedTouches){
      const f=fingers.get(t.identifier);
      if(!f) continue;
      f.x=t.clientX; f.y=t.clientY;

      if(state==="running" && mode==="fingers" && !(f.eightLocked || f.wLocked)){
        trackAndLockIfNeeded(f);
      }
    }
    renderLive();
  },{passive:false});

  zone.addEventListener("touchend", e=>{
    e.preventDefault();
    if(state==="winnerFreeze" || state==="groupsReveal") return;

    let changed=false;
    for(const t of e.changedTouches){
      if(fingers.has(t.identifier)){
        fingers.delete(t.identifier);
        removeDot(t.identifier);
        changed=true;
      }
    }
    lastCount=fingers.size;

    if(changed && state==="running"){
      ensureUniqueRealColors();
      restartRoundTimer();
    }
    renderLive();
  },{passive:false});

  zone.addEventListener("touchcancel", e=>{
    e.preventDefault();
    if(state==="winnerFreeze" || state==="groupsReveal") return;

    let changed=false;
    for(const t of e.changedTouches){
      if(fingers.has(t.identifier)){
        fingers.delete(t.identifier);
        removeDot(t.identifier);
        changed=true;
      }
    }
    lastCount=fingers.size;

    if(changed && state==="running"){
      ensureUniqueRealColors();
      restartRoundTimer();
    }
    renderLive();
  },{passive:false});

  // ---- Modal UI ----
  function updateUI(){
    countEl.textContent = String(selectorValue);
    winBtn.textContent = String(selectorValue) + "F";
    setAccent();
  }
  function openModal(){ overlay.classList.add("on"); }
  function closeModal(){ overlay.classList.remove("on"); }

  winBtn.addEventListener("click",(e)=>{ e.preventDefault(); openModal(); });
  helpBtn.addEventListener("click",(e)=>{ e.preventDefault(); openModal(); });
  overlay.addEventListener("click",(e)=>{ if(e.target===overlay) closeModal(); });

  minusBtn.addEventListener("click",(e)=>{ e.preventDefault(); selectorValue=Math.max(1, selectorValue-1); updateUI(); });
  plusBtn.addEventListener("click",(e)=>{ e.preventDefault(); selectorValue=Math.min(4, selectorValue+1); updateUI(); });

  segFingers.addEventListener("click",(e)=>{
    e.preventDefault();
    mode="fingers";
    segFingers.classList.add("active");
    segGroups.classList.remove("active");
    updateUI();
  });
  segGroups.addEventListener("click",(e)=>{
    e.preventDefault();
    mode="groups";
    segGroups.classList.add("active");
    segFingers.classList.remove("active");
    updateUI();
  });

  // init
  modal.style.setProperty("--accent", "var(--green)");
  stateEl.textContent="esperando";
  setHiddenTextColor("#000");
  updateUI();
})();
</script>
</body>
</html>
