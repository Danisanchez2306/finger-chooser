<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Finger Chooser</title>

<style>
:root{
  --green:#7fb13a;
  --orange:#ff8a00;
}

html, body{
  margin:0;height:100%;background:black;
  font-family:-apple-system,system-ui,sans-serif;overflow:hidden;color:white;
}
#zone{height:100%;touch-action:none;user-select:none;-webkit-user-select:none;}

#colorFill{position:fixed;inset:0;opacity:0;transition:opacity .22s;z-index:1;pointer-events:none;}
#colorFill.on{opacity:1;}

#topbar{
  position:fixed;top:12px;left:12px;right:12px;z-index:10;
  display:flex;justify-content:space-between;align-items:flex-start;gap:12px;
}

/* Texto estado (mismo color que hint) */
#state{
  position:fixed;left:50%;top:16px;transform:translateX(-50%);
  font-size:13px;opacity:.55;text-transform:lowercase;z-index:10;
  pointer-events:none;
  color:#000;
}

/* Botón circular arriba-izquierda */
#winBtn{
  width:76px;height:76px;border-radius:50%;
  background:var(--green);
  display:flex;align-items:center;justify-content:center;
  color:white;font-size:34px;font-weight:500;
  border:none;outline:none;
  box-shadow:0 6px 18px rgba(0,0,0,.35);
  -webkit-tap-highlight-color: transparent;
}

/* Botón ? */
#helpBtn{
  width:76px;height:76px;border-radius:50%;
  background:#ff00a8;
  display:flex;align-items:center;justify-content:center;
  color:white;font-size:44px;font-weight:500;
  border:none;outline:none;
  box-shadow:0 6px 18px rgba(0,0,0,.35);
  -webkit-tap-highlight-color: transparent;
}

/* Texto discreto abajo derecha */
#hint{
  position:fixed;right:10px;bottom:10px;font-size:11px;
  color:#000;opacity:.6;z-index:20;user-select:none;pointer-events:none;
}

/* Modal overlay */
#modalOverlay{
  position:fixed;inset:0;z-index:50;
  display:none;align-items:center;justify-content:center;
  background:rgba(0,0,0,.15);
}
#modalOverlay.on{display:flex;}

/* Panel blanco */
#modal{
  width:min(340px,86vw);
  background:#fff;
  border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.35);
  padding:16px 16px 14px;
  color:#1a1a1a;
}

/* Fila + - número */
#row{
  display:flex;align-items:center;justify-content:space-between;
  padding:4px 6px 14px;
}
.stepBtn{
  width:54px;height:54px;border-radius:50%;
  border:3px solid var(--accent);
  background:#fff;
  color:var(--accent);
  font-size:34px;line-height:0;
  display:flex;align-items:center;justify-content:center;
  -webkit-tap-highlight-color: transparent;
}
#count{
  font-size:44px;font-weight:500;
  color:#4a4a4a;
}

/* Segmented */
#seg{
  width:100%;
  border:2px solid var(--accent);
  border-radius:14px;
  overflow:hidden;
  display:flex;
}
.segBtn{
  flex:1;
  padding:10px 0;
  font-size:18px;
  border:none;outline:none;
  background:#fff;
  color:var(--accent);
}
.segBtn.active{
  background:var(--accent);
  color:#fff;
}

/* =========================
   DOT + RINGS (circle perfecto)
   ========================= */
.dot{
  --c:#ff3b30;
  position:fixed;width:130px;height:130px;border-radius:50%;
  transform:translate(-50%,-50%);
  pointer-events:none;z-index:5;
  opacity:.95;
  transition:opacity .26s, transform .26s, filter .26s;
}

.dot .fill{
  position:absolute;inset:0;border-radius:50%;
  background:var(--c);
}

/* contenedor de aros */
.dot .rings{
  position:absolute;
  inset:-18px;
  width:calc(100% + 36px);
  height:calc(100% + 36px);
  pointer-events:none;
  transform:rotate(0deg);

  /* suaviza en iPhone */
  -webkit-transform:translateZ(0);
  transform:translateZ(0);
  backface-visibility:hidden;
}

/* círculos perfectos */
.dot .arc{
  fill:none;
  stroke:var(--c);
  stroke-linecap:butt;
  vector-effect: non-scaling-stroke;
  shape-rendering: geometricPrecision;
  transform-origin:50% 50%;
}

/* Grosor fijo (NO engorda) */
.dot .arc.outer{
  stroke-width:12;
  opacity:.95;

  /* patrón fijo (no se anima) */
  stroke-dasharray:58 42;
  /* empieza oculto */
  stroke-dashoffset:58;
}
.dot .arc.inner{
  stroke-width:8;
  opacity:.60;

  stroke-dasharray:46 54;
  stroke-dashoffset:46;
}

/* “dibujar aro” — 1,2 segundos (animamos SOLO dashoffset => no serrucho) */
.dot.reveal .arc.outer{ animation:drawOuter 1.2s ease-out forwards; }
.dot.reveal .arc.inner{ animation:drawInner 1.2s ease-out forwards; }

@keyframes drawOuter{ to{ stroke-dashoffset:0; } }
@keyframes drawInner{ to{ stroke-dashoffset:0; } }

/* Durante espera: girar */
.dot.running .rings{
  animation:spin 650ms linear infinite, breathe 900ms ease-in-out infinite;
  will-change: transform, filter;
}
@keyframes spin{ to{ transform:rotate(360deg); } }
@keyframes breathe{
  0%,100%{ filter:brightness(1); }
  50%{ filter:brightness(1.12); }
}

/* Perdedor */
.dot.lose{
  opacity:0;
  transform:translate(-50%,-50%) scale(.78);
  filter:blur(2px) brightness(.9);
}

/* Ganador: donut negro + aro fijo */
@keyframes winPop{
  0%{ transform:translate(-50%,-50%) scale(1.18); }
  100%{ transform:translate(-50%,-50%) scale(1.05); }
}
.dot.win{ animation:winPop .22s ease-out forwards; }
.dot.win .fill{ background:#000 !important; }

/* Aro completo visible al ganar */
.dot.win .arc.outer{ stroke-dashoffset:0 !important; opacity:1; }
.dot.win .arc.inner{ stroke-dashoffset:0 !important; opacity:1; }

/* Un poco más lento al girar el ganador */
.dot.win .rings{
  animation:spin 900ms linear infinite;
  filter:drop-shadow(0 0 2px rgba(0,0,0,.35));
}
</style>
</head>

<body>
<div id="colorFill"></div>

<div id="topbar">
  <button id="winBtn" aria-label="Ganadores">1F</button>
  <button id="helpBtn" aria-label="Ayuda">?</button>
</div>

<div id="state">esperando</div>
<div id="hint">8 gana · W pierde · 7 gana · 9 pierde</div>

<div id="modalOverlay" role="dialog" aria-modal="true">
  <div id="modal">
    <div id="row">
      <button class="stepBtn" id="minus" aria-label="Menos">−</button>
      <div id="count">1</div>
      <button class="stepBtn" id="plus" aria-label="Más">+</button>
    </div>
    <div id="seg">
      <button class="segBtn active" id="segFingers">Fingers</button>
      <button class="segBtn" id="segGroups">Groups</button>
    </div>
  </div>
</div>

<div id="zone"></div>

<script>
(() => {
  const zone = document.getElementById("zone");
  const stateEl = document.getElementById("state");
  const colorFill = document.getElementById("colorFill");
  const hintEl = document.getElementById("hint");

  // UI
  const winBtn = document.getElementById("winBtn");
  const helpBtn = document.getElementById("helpBtn");
  const overlay = document.getElementById("modalOverlay");
  const minusBtn = document.getElementById("minus");
  const plusBtn = document.getElementById("plus");
  const countEl = document.getElementById("count");
  const segFingers = document.getElementById("segFingers");
  const segGroups = document.getElementById("segGroups");
  const modal = document.getElementById("modal");

  let mode = "fingers"; // "fingers" | "groups"
  function setAccent(){
    const accent = (mode === "groups")
      ? getComputedStyle(document.documentElement).getPropertyValue("--orange").trim()
      : getComputedStyle(document.documentElement).getPropertyValue("--green").trim();
    modal.style.setProperty("--accent", accent);
  }

  const MAX=5, ROUND_MS=4000, FILL_MS=5000;
  const COLORS=["#ff3b30","#ff9500","#ffcc00","#34c759","#00c7be","#007aff","#5856d6","#af52de","#ff2d55","#ff6f00"];

  let selectorValue = 1;

  // id -> {x,y,taps,color,path:[], eightLocked:boolean, wLocked:boolean}
  const fingers=new Map();
  const dotEls=new Map();
  let state="waiting", timer=null, lastCount=0;

  const rand=n=>Math.floor(Math.random()*n);
  const shuffle=a=>{a=a.slice();for(let i=a.length-1;i;i--){const j=rand(i+1);[a[i],a[j]]=[a[j],a[i]]}return a};

  const ensureDot=id=>{
    if(dotEls.has(id)) return dotEls.get(id);

    const d=document.createElement("div");
    d.className="dot";
    d.innerHTML = `
      <div class="fill"></div>
      <svg class="rings" viewBox="0 0 100 100" aria-hidden="true">
        <circle class="arc outer" cx="50" cy="50" r="44" pathLength="100"></circle>
        <circle class="arc inner" cx="50" cy="50" r="36" pathLength="100"></circle>
      </svg>
    `;
    document.body.appendChild(d);
    dotEls.set(id,d);
    return d;
  };

  const removeDot=id=>{ if(dotEls.has(id)){dotEls.get(id).remove(); dotEls.delete(id)} };

  function ensureUniqueColorsStable(){
    const used = new Set();
    for (const f of fingers.values()){
      if (f.color) used.add(f.color);
    }
    const available = shuffle(COLORS.filter(c => !used.has(c)));
    for (const f of fingers.values()){
      if (!f.color){
        f.color = available.length ? available.pop() : COLORS[rand(COLORS.length)];
        used.add(f.color);
      }
    }
  }

  function renderLive(){
    for(const [id,f] of fingers){
      const el=ensureDot(id);
      el.style.left=f.x+"px"; el.style.top=f.y+"px";
      const c=f.color||COLORS[0];
      el.style.setProperty("--c",c);
      el.classList.toggle("running", state==="running");
      el.classList.remove("win","lose");
    }
    for(const [id] of dotEls){ if(!fingers.has(id)) removeDot(id); }
  }

  function setHiddenTextColor(color){
    hintEl.style.color = color;
    stateEl.style.color = color;
  }

  function setFillFromColors(colors){
    if(colors.length<=1) colorFill.style.background=colors[0]||"black";
    else{
      const stops=colors.map((c,i)=>`${c} ${Math.round(i/(colors.length-1)*100)}%`).join(", ");
      colorFill.style.background=`linear-gradient(135deg, ${stops})`;
    }
  }

  function setHintColorWhenFill(on, color){
    setHiddenTextColor(on ? (color || "#000") : "#000");
  }

  function restartRoundTimer(){
    if(state!=="running") return;
    clearTimeout(timer);
    timer=setTimeout(endRound,ROUND_MS);
  }

  function startRound(){
    if(fingers.size<2) return;
    state="running";
    stateEl.textContent="jugando";

    for(const f of fingers.values()){
      f.taps = 0;
      f.path = [];
      f.eightLocked = false;
      f.wLocked = false;
    }

    ensureUniqueColorsStable();
    renderLive();

    clearTimeout(timer);
    timer=setTimeout(endRound,ROUND_MS);
  }

  function isEight(path){
    if(path.length < 14) return false;

    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of path){
      minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
      minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
    }
    const w=maxX-minX, h=maxY-minY;
    const size=Math.max(w,h);
    if(size < 70) return false;

    let turns=0;
    for(let i=2;i<path.length;i++){
      const aY = path[i-2].y - path[i-1].y;
      const bY = path[i-1].y - path[i].y;
      if(aY*bY < 0) turns++;
    }
    if(turns < 6) return false;

    const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
    let crosses=0;
    const r = Math.min(w,h) * 0.14;
    for(const p of path){
      if(Math.hypot(p.x-cx,p.y-cy) < r) crosses++;
    }
    if(crosses < 2) return false;

    return true;
  }

  function isW(path){
    if(path.length < 10) return false;

    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of path){
      minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
      minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
    }
    const w=maxX-minX, h=maxY-minY;
    const size=Math.max(w,h);
    if(size < 70) return false;

    let changes=0;
    for(let i=2;i<path.length;i++){
      const a=path[i-2].y - path[i-1].y;
      const b=path[i-1].y - path[i].y;
      if(a*b < 0) changes++;
    }
    return changes >= 3;
  }

  function trackAndLockIfNeeded(f){
    if(!f || f.eightLocked || f.wLocked) return;
    f.path.push({x:f.x,y:f.y});
    if(isEight(f.path)){
      f.eightLocked = true;
      f.wLocked = false;
      f.path = f.path.slice(-80);
      return;
    }
    if(isW(f.path)){
      f.wLocked = true;
      f.eightLocked = false;
      f.path = f.path.slice(-80);
      return;
    }
  }

  function pickWinners(ids,k){
    const pool=ids.slice(), out=[], want=Math.min(k,pool.length);
    for(let i=0;i<want;i++){
      const idx=rand(pool.length);
      out.push(pool[idx]);
      pool.splice(idx,1);
    }
    return out;
  }

  function assignGroups(ids, groupCount){
    const shuffled = shuffle(ids);
    const groups = Array.from({length: groupCount}, () => []);
    let gi = 0;
    for(const id of shuffled){
      groups[gi].push(id);
      gi = (gi + 1) % groupCount;
    }
    return groups;
  }

  function endRound(){
    state="fin";
    stateEl.textContent="fin";

    const entries=[...fingers.entries()];
    const idsAll = entries.map(([id])=>id);

    const eights = entries.filter(([_,f])=>f.eightLocked).map(([id])=>id);
    const sevens = entries.filter(([_,f])=>f.taps===7).map(([id])=>id);
    const banned9= entries.filter(([_,f])=>f.taps===9).map(([id])=>id);
    const bannedW= entries.filter(([_,f])=>f.wLocked).map(([id])=>id);
    const banned = new Set([...bannedW, ...banned9]);

    let survivors = [];

    if(mode === "fingers"){
      const wanted = selectorValue;

      if(eights.length){
        survivors = pickWinners(eights, wanted);
      }else if(sevens.length){
        survivors = pickWinners(sevens, wanted);
      }else{
        const allowed = idsAll.filter(id=>!banned.has(id));
        survivors = allowed.length ? pickWinners(allowed, wanted)
                                  : pickWinners(idsAll, wanted);
      }
    }else{
      const groupCount = selectorValue;

      const allowed = idsAll.filter(id=>!banned.has(id));
      const pool = allowed.length ? allowed : idsAll;

      const groups = assignGroups(pool, groupCount);

      let winnerGroupIndex = rand(groups.length);

      const eightInPool = eights.filter(id => pool.includes(id));
      if(eightInPool.length){
        const target = eightInPool[0];
        for(let i=0;i<groups.length;i++){
          if(groups[i].includes(target)){ winnerGroupIndex = i; break; }
        }
      }else if(sevens.length){
        const target = sevens.find(id => pool.includes(id));
        if(target){
          for(let i=0;i<groups.length;i++){
            if(groups[i].includes(target)){ winnerGroupIndex = i; break; }
          }
        }
      }

      survivors = groups[winnerGroupIndex].slice();
    }

    const winSet=new Set(survivors);

    for(const [id] of fingers){
      const el=dotEls.get(id);
      if(!el) continue;
      el.classList.remove("running");
      el.classList.add(winSet.has(id) ? "win" : "lose");

      // aro visible sí o sí
      el.classList.add("reveal");
    }

    const winColors=survivors.map(id=>fingers.get(id)?.color).filter(Boolean);
    setFillFromColors(winColors);
    colorFill.classList.add("on");
    setHintColorWhenFill(true, winColors[0] || "#000");

    clearTimeout(timer);
    timer=setTimeout(()=>{
      colorFill.classList.remove("on");
      setHintColorWhenFill(false);

      for(const [id] of dotEls){
        if(!winSet.has(id)) removeDot(id);
      }

      state="waiting";
      stateEl.textContent="esperando";

      for(const [id] of fingers){
        const el=dotEls.get(id);
        if(el) el.classList.remove("win","lose","running","reveal");
      }
      renderLive();
    }, FILL_MS);
  }

  // --- Touch events ---
  zone.addEventListener("touchstart", e=>{
    e.preventDefault();
    let changed=false;

    for(const t of e.changedTouches){
      const id=t.identifier;

      if(!fingers.has(id) && fingers.size < MAX){
        fingers.set(id, {x:t.clientX, y:t.clientY, taps:0, color:null, path:[], eightLocked:false, wLocked:false});
        changed=true;
      }

      const f=fingers.get(id);
      if(f){
        f.x=t.clientX; f.y=t.clientY;

        const el = ensureDot(id);

        // retrigger del “dibujar aro”
        el.classList.remove("reveal");
        void el.offsetWidth;
        el.classList.add("reveal");

        if(state==="running"){
          f.taps++;
          trackAndLockIfNeeded(f);
        }
      }
    }

    if(state==="waiting" && lastCount<2 && fingers.size>=2){
      startRound();
    }

    if(changed){
      ensureUniqueColorsStable();
      if(state==="running") restartRoundTimer();
    }

    lastCount=fingers.size;
    if(state!=="fin") renderLive();
  }, {passive:false});

  zone.addEventListener("touchmove", e=>{
    e.preventDefault();
    if(state!=="running") return;

    for(const t of e.changedTouches){
      const f=fingers.get(t.identifier);
      if(!f) continue;

      f.x=t.clientX; f.y=t.clientY;
      if(f.eightLocked || f.wLocked) continue;
      trackAndLockIfNeeded(f);
    }
    renderLive();
  }, {passive:false});

  zone.addEventListener("touchend", e=>{
    e.preventDefault();
    let changed=false;

    for(const t of e.changedTouches){
      if(fingers.has(t.identifier)){
        const f=fingers.get(t.identifier);
        if(state==="running" && f && !(f.eightLocked || f.wLocked)){
          trackAndLockIfNeeded(f);
        }
        fingers.delete(t.identifier);
        removeDot(t.identifier);
        changed=true;
      }
    }

    lastCount=fingers.size;

    if(changed && state==="running"){
      ensureUniqueColorsStable();
      restartRoundTimer();
      renderLive();
    }
  }, {passive:false});

  zone.addEventListener("touchcancel", e=>{
    e.preventDefault();
    let changed=false;

    for(const t of e.changedTouches){
      if(fingers.has(t.identifier)){
        const f=fingers.get(t.identifier);
        if(state==="running" && f && !(f.eightLocked || f.wLocked)){
          trackAndLockIfNeeded(f);
        }
        fingers.delete(t.identifier);
        removeDot(t.identifier);
        changed=true;
      }
    }

    lastCount=fingers.size;

    if(changed && state==="running"){
      ensureUniqueColorsStable();
      restartRoundTimer();
      renderLive();
    }
  }, {passive:false});

  // --- UI modal ---
  function updateUI(){
    countEl.textContent = String(selectorValue);
    winBtn.textContent = String(selectorValue) + "F";
    winBtn.style.background = (mode === "groups") ? "var(--orange)" : "var(--green)";
    setAccent();
  }
  function openModal(){ overlay.classList.add("on"); }
  function closeModal(){ overlay.classList.remove("on"); }

  winBtn.addEventListener("click",(e)=>{ e.preventDefault(); openModal(); });
  helpBtn.addEventListener("click",(e)=>{ e.preventDefault(); openModal(); });

  overlay.addEventListener("click",(e)=>{ if(e.target===overlay) closeModal(); });

  minusBtn.addEventListener("click",(e)=>{
    e.preventDefault();
    selectorValue = Math.max(1, selectorValue - 1);
    updateUI();
  });
  plusBtn.addEventListener("click",(e)=>{
    e.preventDefault();
    selectorValue = Math.min(4, selectorValue + 1);
    updateUI();
  });

  segFingers.addEventListener("click",(e)=>{
    e.preventDefault();
    mode="fingers";
    segFingers.classList.add("active");
    segGroups.classList.remove("active");
    updateUI();
  });
  segGroups.addEventListener("click",(e)=>{
    e.preventDefault();
    mode="groups";
    segGroups.classList.add("active");
    segFingers.classList.remove("active");
    updateUI();
  });

  // init
  modal.style.setProperty("--accent", "var(--green)");
  setAccent();
  updateUI();

  stateEl.textContent="esperando";
  setHintColorWhenFill(false);
  ensureUniqueColorsStable();
  renderLive();
})();
</script>
</body>
</html>
