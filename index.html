<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Finger Chooser</title>

<style>
html, body{
  margin:0;height:100%;background:black;
  font-family:-apple-system,system-ui,sans-serif;overflow:hidden;color:white;
}
#zone{height:100%;touch-action:none;user-select:none;-webkit-user-select:none;}

#colorFill{position:fixed;inset:0;opacity:0;transition:opacity .22s;z-index:1;pointer-events:none;}
#colorFill.on{opacity:1;}

#topbar{
  position:fixed;top:12px;left:12px;right:12px;z-index:10;
  display:flex;justify-content:space-between;align-items:flex-start;gap:12px;
}
#state{
  position:fixed;left:50%;top:16px;transform:translateX(-50%);
  font-size:14px;opacity:.55;text-transform:lowercase;z-index:10;
  pointer-events:none;
}

/* Botón circular verde arriba-izquierda (1F) */
#winBtn{
  width:76px;height:76px;border-radius:50%;
  background:#7fb13a;
  display:flex;align-items:center;justify-content:center;
  color:white;font-size:34px;font-weight:500;
  border:none;outline:none;
  box-shadow:0 6px 18px rgba(0,0,0,.35);
  -webkit-tap-highlight-color: transparent;
}

/* Botón ? arriba-derecha (solo decorativo/ayuda) */
#helpBtn{
  width:76px;height:76px;border-radius:50%;
  background:#ff00a8;
  display:flex;align-items:center;justify-content:center;
  color:white;font-size:44px;font-weight:500;
  border:none;outline:none;
  box-shadow:0 6px 18px rgba(0,0,0,.35);
  -webkit-tap-highlight-color: transparent;
}

/* Texto discreto abajo derecha */
#hint{
  position:fixed;right:10px;bottom:10px;font-size:11px;
  color:#000;opacity:.6;z-index:20;user-select:none;pointer-events:none;
}

/* Modal overlay */
#modalOverlay{
  position:fixed;inset:0;z-index:50;
  display:none;align-items:center;justify-content:center;
  background:rgba(0,0,0,.15);
}
#modalOverlay.on{display:flex;}

/* Panel blanco */
#modal{
  width:min(340px,86vw);
  background:#fff;
  border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.35);
  padding:16px 16px 14px;
  color:#1a1a1a;
}

/* Fila + - número */
#row{
  display:flex;align-items:center;justify-content:space-between;
  padding:4px 6px 14px;
}
.stepBtn{
  width:54px;height:54px;border-radius:50%;
  border:3px solid #7fb13a;
  background:#fff;
  color:#7fb13a;
  font-size:34px;line-height:0;
  display:flex;align-items:center;justify-content:center;
  -webkit-tap-highlight-color: transparent;
}
#count{
  font-size:44px;font-weight:500;
}

/* Segmented */
#seg{
  width:100%;
  border:2px solid #7fb13a;
  border-radius:14px;
  overflow:hidden;
  display:flex;
}
.segBtn{
  flex:1;
  padding:10px 0;
  font-size:18px;
  border:none;outline:none;
  background:#fff;
  color:#7fb13a;
}
.segBtn.active{
  background:#7fb13a;
  color:#fff;
}

/* Círculo */
.dot{
  --c:#ff3b30;
  position:fixed;width:130px;height:130px;border-radius:50%;
  transform:translate(-50%,-50%);pointer-events:none;z-index:5;
  box-shadow:0 0 40px rgba(255,255,255,.22);opacity:.95;
  transition:opacity .26s, transform .26s, filter .26s;
}

/* Aro estilo Chwazi */
.dot::before{
  content:"";position:absolute;inset:-14px;border-radius:50%;
  background:conic-gradient(
    var(--c) 0deg, var(--c) 70deg,
    transparent 70deg, transparent 180deg,
    var(--c) 180deg, var(--c) 250deg,
    transparent 250deg, transparent 360deg
  );
  -webkit-mask:radial-gradient(circle,transparent 58%,#000 60%);
  mask:radial-gradient(circle,transparent 58%,#000 60%);
}
.dot.running::before{animation:ringSpin .7s linear infinite;}
@keyframes ringSpin{to{transform:rotate(360deg)}}

/* Perdedor */
.dot.lose{
  opacity:0;transform:translate(-50%,-50%) scale(.78);
  filter:blur(2px) brightness(.9);
}

/* Ganador: donut negro + anillos */
@keyframes winPop{
  0%{transform:translate(-50%,-50%) scale(1.25)}
  100%{transform:translate(-50%,-50%) scale(1.05)}
}
.dot.win{
  background:#000 !important;box-shadow:none;opacity:1;
  animation:winPop .22s ease-out forwards;
}
.dot.win::before{content:none;}
.dot.win::after{
  content:"";position:absolute;inset:30px;border-radius:50%;
  box-shadow:inset 0 0 0 10px var(--c), inset 0 0 0 18px #000;
}
</style>
</head>

<body>
<div id="colorFill"></div>

<div id="topbar">
  <button id="winBtn" aria-label="Ganadores">1F</button>
  <button id="helpBtn" aria-label="Ayuda">?</button>
</div>

<div id="state">esperando</div>
<div id="hint">8 gana · W pierde · 7 gana · 9 pierde</div>

<div id="modalOverlay" role="dialog" aria-modal="true">
  <div id="modal">
    <div id="row">
      <button class="stepBtn" id="minus" aria-label="Menos">−</button>
      <div id="count">1</div>
      <button class="stepBtn" id="plus" aria-label="Más">+</button>
    </div>
    <div id="seg">
      <button class="segBtn active" id="segFingers">Fingers</button>
      <button class="segBtn" id="segGroups">Groups</button>
    </div>
  </div>
</div>

<div id="zone"></div>

<script>
(() => {
  const zone = document.getElementById("zone");
  const stateEl = document.getElementById("state");
  const colorFill = document.getElementById("colorFill");
  const hintEl = document.getElementById("hint");

  // UI
  const winBtn = document.getElementById("winBtn");
  const helpBtn = document.getElementById("helpBtn");
  const overlay = document.getElementById("modalOverlay");
  const minusBtn = document.getElementById("minus");
  const plusBtn = document.getElementById("plus");
  const countEl = document.getElementById("count");
  const segFingers = document.getElementById("segFingers");
  const segGroups = document.getElementById("segGroups");

  const MAX=5, ROUND_MS=4000, FILL_MS=5000;
  const COLORS=["#ff3b30","#ff9500","#ffcc00","#34c759","#00c7be","#007aff","#5856d6","#af52de","#ff2d55","#ff6f00"];

  // Estado ganadores (1–4)
  let winnerCount = 1;

  // id -> {x,y,taps,color,path:[], eightLocked:boolean, wLocked:boolean}
  const fingers=new Map();
  const dotEls=new Map();
  let state="waiting", timer=null, lastCount=0;

  const rand=n=>Math.floor(Math.random()*n);
  const shuffle=a=>{a=a.slice();for(let i=a.length-1;i;i--){const j=rand(i+1);[a[i],a[j]]=[a[j],a[i]]}return a};

  const ensureDot=id=>{
    if(dotEls.has(id)) return dotEls.get(id);
    const d=document.createElement("div"); d.className="dot";
    document.body.appendChild(d); dotEls.set(id,d); return d;
  };
  const removeDot=id=>{ if(dotEls.has(id)){dotEls.get(id).remove(); dotEls.delete(id)} };

  function ensureUniqueColorsStable(){
    const used = new Set();
    for (const f of fingers.values()){
      if (f.color) used.add(f.color);
    }
    const available = shuffle(COLORS.filter(c => !used.has(c)));
    for (const f of fingers.values()){
      if (!f.color){
        f.color = available.length ? available.pop() : COLORS[rand(COLORS.length)];
        used.add(f.color);
      }
    }
  }

  function renderLive(){
    for(const [id,f] of fingers){
      const el=ensureDot(id);
      el.style.left=f.x+"px"; el.style.top=f.y+"px";
      const c=f.color||COLORS[0];
      el.style.background=c; el.style.setProperty("--c",c);
      el.classList.toggle("running",state==="running");
      el.classList.remove("win","lose");
    }
    for(const [id] of dotEls){ if(!fingers.has(id)) removeDot(id); }
  }

  function restartRoundTimer(){
    if(state!=="running") return;
    clearTimeout(timer);
    timer=setTimeout(endRound,ROUND_MS);
  }

  function startRound(){
    if(fingers.size<2) return;
    state="running"; stateEl.textContent="jugando";

    // no mantener 8/W entre rondas
    for(const f of fingers.values()){
      f.taps = 0;
      f.path = [];
      f.eightLocked = false;
      f.wLocked = false;
    }

    ensureUniqueColorsStable();
    renderLive();

    clearTimeout(timer);
    timer=setTimeout(endRound,ROUND_MS);
  }

  // 8 gana (no muy estricto)
  function isEight(path){
    if(path.length < 14) return false;

    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of path){
      minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
      minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
    }
    const w=maxX-minX, h=maxY-minY;
    const size=Math.max(w,h);
    if(size < 70) return false;

    let turns=0;
    for(let i=2;i<path.length;i++){
      const aY = path[i-2].y - path[i-1].y;
      const bY = path[i-1].y - path[i].y;
      if(aY*bY < 0) turns++;
    }
    if(turns < 6) return false;

    const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
    let crosses=0;
    const r = Math.min(w,h) * 0.14;
    for(const p of path){
      if(Math.hypot(p.x-cx,p.y-cy) < r) crosses++;
    }
    if(crosses < 2) return false;

    return true;
  }

  // W pierde (no muy estricta)
  function isW(path){
    if(path.length < 10) return false;

    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of path){
      minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
      minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
    }
    const w=maxX-minX, h=maxY-minY;
    const size=Math.max(w,h);
    if(size < 70) return false;

    let changes=0;
    for(let i=2;i<path.length;i++){
      const a=path[i-2].y - path[i-1].y;
      const b=path[i-1].y - path[i].y;
      if(a*b < 0) changes++;
    }
    return changes >= 3;
  }

  function pickWinners(ids,k){
    const pool=ids.slice(), out=[], want=Math.min(k,pool.length);
    for(let i=0;i<want;i++){
      const idx=rand(pool.length);
      out.push(pool[idx]);
      pool.splice(idx,1);
    }
    return out;
  }

  function setFillFromColors(colors){
    if(colors.length<=1) colorFill.style.background=colors[0]||"black";
    else{
      const stops=colors.map((c,i)=>`${c} ${Math.round(i/(colors.length-1)*100)}%`).join(", ");
      colorFill.style.background=`linear-gradient(135deg, ${stops})`;
    }
  }

  function setHintColorWhenFill(on, color){
    hintEl.style.color = on ? (color || "#000") : "#000";
  }

  function endRound(){
    state="fin"; stateEl.textContent="fin";
    const wanted = winnerCount;
    const entries=[...fingers.entries()];

    const eights = entries.filter(([_,f])=>f.eightLocked === true).map(([id])=>id);
    const sevens = entries.filter(([_,f])=>f.taps===7).map(([id])=>id);
    const banned9= entries.filter(([_,f])=>f.taps===9).map(([id])=>id);
    const bannedW= entries.filter(([_,f])=>f.wLocked === true).map(([id])=>id);

    const banned = new Set([...bannedW, ...banned9]);

    let winners=[];
    if(eights.length){
      winners = pickWinners(eights, wanted);
    }else if(sevens.length){
      winners = pickWinners(sevens, wanted);
    }else{
      const allowed = entries.map(([id])=>id).filter(id=>!banned.has(id));
      winners = allowed.length ? pickWinners(allowed, wanted)
                               : pickWinners(entries.map(([id])=>id), wanted);
    }

    const winSet=new Set(winners);

    for(const [id] of fingers){
      const el=dotEls.get(id);
      if(!el) continue;
      el.classList.remove("running");
      el.classList.add(winSet.has(id) ? "win" : "lose");
    }

    const winColors=winners.map(id=>fingers.get(id)?.color).filter(Boolean);
    setFillFromColors(winColors);
    colorFill.classList.add("on");

    setHintColorWhenFill(true, winColors[0] || "#000");

    clearTimeout(timer);
    timer=setTimeout(()=>{
      colorFill.classList.remove("on");
      setHintColorWhenFill(false);

      for(const [id] of dotEls){
        if(!winSet.has(id)) removeDot(id);
      }

      state="waiting"; stateEl.textContent="esperando";
      for(const [id] of fingers){
        const el=dotEls.get(id);
        if(el) el.classList.remove("win","lose","running");
      }
      renderLive();
    }, FILL_MS);
  }

  // Track + lock (para que si cierras el 8 o la W, ya no se estropee)
  function trackAndLockIfNeeded(f){
    if(!f || f.eightLocked || f.wLocked) return;

    f.path.push({x:f.x,y:f.y});

    // prioridad: 8
    if(isEight(f.path)){
      f.eightLocked = true;
      f.wLocked = false;
      f.path = f.path.slice(-80);
      return;
    }

    // W
    if(isW(f.path)){
      f.wLocked = true;
      f.eightLocked = false;
      f.path = f.path.slice(-80);
      return;
    }
  }

  // --- Touch events ---
  zone.addEventListener("touchstart", e=>{
    e.preventDefault();
    let changed=false;

    for(const t of e.changedTouches){
      const id=t.identifier;

      if(!fingers.has(id) && fingers.size < MAX){
        fingers.set(id, {x:t.clientX, y:t.clientY, taps:0, color:null, path:[], eightLocked:false, wLocked:false});
        changed=true;
      }

      const f=fingers.get(id);
      if(f){
        f.x=t.clientX; f.y=t.clientY;

        if(state==="running"){
          f.taps++;
          trackAndLockIfNeeded(f);
        }
      }
    }

    if(state==="waiting" && lastCount<2 && fingers.size>=2) startRound();

    if(changed){
      ensureUniqueColorsStable();
      if(state==="running") restartRoundTimer();
    }

    lastCount=fingers.size;
    if(state!=="fin") renderLive();
  }, {passive:false});

  zone.addEventListener("touchmove", e=>{
    e.preventDefault();
    if(state!=="running") return;

    for(const t of e.changedTouches){
      const f=fingers.get(t.identifier);
      if(!f) continue;

      f.x=t.clientX; f.y=t.clientY;
      if(f.eightLocked || f.wLocked) continue;

      trackAndLockIfNeeded(f);
    }
    renderLive();
  }, {passive:false});

  zone.addEventListener("touchend", e=>{
    e.preventDefault();
    let changed=false;

    for(const t of e.changedTouches){
      if(fingers.has(t.identifier)){
        const f=fingers.get(t.identifier);

        if(state==="running" && f && !(f.eightLocked || f.wLocked)){
          trackAndLockIfNeeded(f);
        }

        fingers.delete(t.identifier);
        removeDot(t.identifier);
        changed=true;
      }
    }

    lastCount=fingers.size;

    if(changed && state==="running"){
      ensureUniqueColorsStable();
      restartRoundTimer();
      renderLive();
    }
  }, {passive:false});

  zone.addEventListener("touchcancel", e=>{
    e.preventDefault();
    let changed=false;

    for(const t of e.changedTouches){
      if(fingers.has(t.identifier)){
        const f=fingers.get(t.identifier);
        if(state==="running" && f && !(f.eightLocked || f.wLocked)){
          trackAndLockIfNeeded(f);
        }
        fingers.delete(t.identifier);
        removeDot(t.identifier);
        changed=true;
      }
    }

    lastCount=fingers.size;

    if(changed && state==="running"){
      ensureUniqueColorsStable();
      restartRoundTimer();
      renderLive();
    }
  }, {passive:false});

  // --- UI: modal winners ---
  function updateWinnersUI(){
    countEl.textContent = String(winnerCount);
    winBtn.textContent = String(winnerCount) + "F";
  }
  updateWinnersUI();

  function openModal(){
    overlay.classList.add("on");
  }
  function closeModal(){
    overlay.classList.remove("on");
  }

  winBtn.addEventListener("click", (e)=>{ e.preventDefault(); openModal(); });
  overlay.addEventListener("click", (e)=>{
    if(e.target === overlay) closeModal();
  });

  minusBtn.addEventListener("click", (e)=>{
    e.preventDefault();
    winnerCount = Math.max(1, winnerCount - 1);
    updateWinnersUI();
  });
  plusBtn.addEventListener("click", (e)=>{
    e.preventDefault();
    winnerCount = Math.min(4, winnerCount + 1);
    updateWinnersUI();
  });

  segFingers.addEventListener("click",(e)=>{
    e.preventDefault();
    segFingers.classList.add("active");
    segGroups.classList.remove("active");
  });
  segGroups.addEventListener("click",(e)=>{
    e.preventDefault();
    // Solo visual (como en tu captura)
    segGroups.classList.add("active");
    segFingers.classList.remove("active");
    // volvemos a Fingers automáticamente al cerrar, para que no confunda
    setTimeout(()=>{
      segFingers.classList.add("active");
      segGroups.classList.remove("active");
    }, 250);
  });

  helpBtn.addEventListener("click",(e)=>{
    e.preventDefault();
    // Minimalista: abre/cierra el modal también (o puedes poner instrucciones)
    openModal();
  });

  // init
  stateEl.textContent="esperando";
  ensureUniqueColorsStable();
  renderLive();
})();
</script>
</body>
</html>
