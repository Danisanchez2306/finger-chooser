<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Finger Chooser</title>

<style>
html, body{
  margin:0;height:100%;background:black;
  font-family:-apple-system,system-ui,sans-serif;overflow:hidden;color:white;
}
#zone{height:100%;touch-action:none;user-select:none;-webkit-user-select:none;}

#colorFill{position:fixed;inset:0;opacity:0;transition:opacity .22s;z-index:1;pointer-events:none;}
#colorFill.on{opacity:1;}

#topbar{
  position:fixed;top:12px;left:12px;right:12px;z-index:10;
  display:flex;justify-content:space-between;align-items:center;gap:12px;
}
#state{font-size:18px;opacity:.95;text-transform:lowercase;}
#controls{
  display:flex;align-items:center;gap:8px;
  background:rgba(255,255,255,.10);padding:10px 12px;border-radius:16px;
}
#winnerCount{
  appearance:none;-webkit-appearance:none;
  border:1px solid rgba(255,255,255,.25);
  background:rgba(0,0,0,.35);color:white;
  padding:8px 10px;border-radius:12px;font-size:14px;outline:none;
}

/* Texto discreto abajo derecha */
#hint{
  position:fixed;right:10px;bottom:10px;font-size:11px;
  color:#000;opacity:.6;z-index:20;user-select:none;pointer-events:none;
}

/* Círculo */
.dot{
  --c:#ff3b30;
  position:fixed;width:130px;height:130px;border-radius:50%;
  transform:translate(-50%,-50%);pointer-events:none;z-index:5;
  box-shadow:0 0 40px rgba(255,255,255,.22);opacity:.95;
  transition:opacity .26s, transform .26s, filter .26s;
}

/* Aro estilo Chwazi */
.dot::before{
  content:"";position:absolute;inset:-14px;border-radius:50%;
  background:conic-gradient(
    var(--c) 0deg, var(--c) 70deg,
    transparent 70deg, transparent 180deg,
    var(--c) 180deg, var(--c) 250deg,
    transparent 250deg, transparent 360deg
  );
  -webkit-mask:radial-gradient(circle,transparent 58%,#000 60%);
  mask:radial-gradient(circle,transparent 58%,#000 60%);
}
.dot.running::before{animation:ringSpin .7s linear infinite;}
@keyframes ringSpin{to{transform:rotate(360deg)}}

/* Perdedor */
.dot.lose{
  opacity:0;transform:translate(-50%,-50%) scale(.78);
  filter:blur(2px) brightness(.9);
}

/* Ganador: donut negro + anillos */
@keyframes winPop{
  0%{transform:translate(-50%,-50%) scale(1.25)}
  100%{transform:translate(-50%,-50%) scale(1.05)}
}
.dot.win{
  background:#000 !important;box-shadow:none;opacity:1;
  animation:winPop .22s ease-out forwards;
}
.dot.win::before{content:none;}
.dot.win::after{
  content:"";position:absolute;inset:30px;border-radius:50%;
  box-shadow:inset 0 0 0 10px var(--c), inset 0 0 0 18px #000;
}
</style>
</head>

<body>
<div id="colorFill"></div>

<div id="topbar">
  <div id="state">esperando</div>
  <div id="controls">
    <select id="winnerCount">
      <option value="1" selected>1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
    </select>
  </div>
</div>

<div id="hint">8 gana · W pierde · 7 gana · 9 pierde</div>
<div id="zone"></div>

<script>
(() => {
  const zone = document.getElementById("zone");
  const stateEl = document.getElementById("state");
  const winnerCountEl = document.getElementById("winnerCount");
  const colorFill = document.getElementById("colorFill");
  const hintEl = document.getElementById("hint");

  const MAX=5, ROUND_MS=4000, FILL_MS=5000;
  const COLORS=["#ff3b30","#ff9500","#ffcc00","#34c759","#00c7be","#007aff","#5856d6","#af52de","#ff2d55","#ff6f00"];

  // id -> {x,y,taps,color,path:[], eightLocked:boolean, wLocked:boolean}
  const fingers=new Map();
  const dotEls=new Map();
  let state="waiting", timer=null, lastCount=0;

  const rand=n=>Math.floor(Math.random()*n);
  const shuffle=a=>{a=a.slice();for(let i=a.length-1;i;i--){const j=rand(i+1);[a[i],a[j]]=[a[j],a[i]]}return a};

  const ensureDot=id=>{
    if(dotEls.has(id)) return dotEls.get(id);
    const d=document.createElement("div"); d.className="dot";
    document.body.appendChild(d); dotEls.set(id,d); return d;
  };
  const removeDot=id=>{ if(dotEls.has(id)){dotEls.get(id).remove(); dotEls.delete(id)} };

  // Mantiene colores ya asignados y solo asigna a dedos nuevos (sin repetir)
  function ensureUniqueColorsStable(){
    const used = new Set();
    for (const f of fingers.values()){
      if (f.color) used.add(f.color);
    }
    const available = shuffle(COLORS.filter(c => !used.has(c)));
    for (const f of fingers.values()){
      if (!f.color){
        f.color = available.length ? available.pop() : COLORS[rand(COLORS.length)];
        used.add(f.color);
      }
    }
  }

  function renderLive(){
    for(const [id,f] of fingers){
      const el=ensureDot(id);
      el.style.left=f.x+"px"; el.style.top=f.y+"px";
      const c=f.color||COLORS[0];
      el.style.background=c; el.style.setProperty("--c",c);
      el.classList.toggle("running",state==="running");
      el.classList.remove("win","lose");
    }
    for(const [id] of dotEls){ if(!fingers.has(id)) removeDot(id); }
  }

  function restartRoundTimer(){
    if(state!=="running") return;
    clearTimeout(timer);
    timer=setTimeout(endRound,ROUND_MS);
  }

  function startRound(){
    if(fingers.size<2) return;
    state="running"; stateEl.textContent="jugando";

    // ✅ NO se mantienen entre rondas
    for(const f of fingers.values()){
      f.taps = 0;
      f.path = [];
      f.eightLocked = false;
      f.wLocked = false;
    }

    ensureUniqueColorsStable();
    renderLive();

    clearTimeout(timer);
    timer=setTimeout(endRound,ROUND_MS);
  }

  // --- Detección 8 (no muy estricta) ---
  function isEight(path){
    if(path.length < 14) return false;

    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of path){
      minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
      minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
    }
    const w=maxX-minX, h=maxY-minY;
    const size=Math.max(w,h);
    if(size < 70) return false;

    // cambios verticales (dos bucles)
    let turns=0;
    for(let i=2;i<path.length;i++){
      const aY = path[i-2].y - path[i-1].y;
      const bY = path[i-1].y - path[i].y;
      if(aY*bY < 0) turns++;
    }
    if(turns < 6) return false;

    // cruce cerca del centro
    const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
    let crosses=0;
    const r = Math.min(w,h) * 0.14;
    for(const p of path){
      if(Math.hypot(p.x-cx,p.y-cy) < r) crosses++;
    }
    if(crosses < 2) return false;

    return true;
  }

  // --- Detección W (no muy estricta) + tamaño mínimo ---
  function isW(path){
    if(path.length < 10) return false;

    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of path){
      minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
      minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
    }
    const w=maxX-minX, h=maxY-minY;
    const size=Math.max(w,h);
    if(size < 70) return false;

    // “picos”: cambios de dirección en Y
    let changes=0;
    for(let i=2;i<path.length;i++){
      const a=path[i-2].y - path[i-1].y;
      const b=path[i-1].y - path[i].y;
      if(a*b < 0) changes++;
    }

    // No muy estricta: con 3 cambios claros ya vale
    // (una W típica dará 4+)
    return changes >= 3;
  }

  function pickWinners(ids,k){
    const pool=ids.slice(), out=[], want=Math.min(k,pool.length);
    for(let i=0;i<want;i++){
      const idx=rand(pool.length);
      out.push(pool[idx]);
      pool.splice(idx,1);
    }
    return out;
  }

  function setFillFromColors(colors){
    if(colors.length<=1) colorFill.style.background=colors[0]||"black";
    else{
      const stops=colors.map((c,i)=>`${c} ${Math.round(i/(colors.length-1)*100)}%`).join(", ");
      colorFill.style.background=`linear-gradient(135deg, ${stops})`;
    }
  }

  function setHintColorWhenFill(on, color){
    if(on){
      hintEl.style.color = color || "#000";
    }else{
      hintEl.style.color = "#000";
    }
  }

  function endRound(){
    state="fin"; stateEl.textContent="fin";
    const wanted = (+winnerCountEl.value || 1);
    const entries=[...fingers.entries()];

    // 8 bloqueado (prioridad)
    const eights = entries.filter(([_,f])=>f.eightLocked === true).map(([id])=>id);

    // 7/9
    const sevens = entries.filter(([_,f])=>f.taps===7).map(([id])=>id);
    const banned9= entries.filter(([_,f])=>f.taps===9).map(([id])=>id);

    // W bloqueada (solo ronda)
    const bannedW= entries.filter(([_,f])=>f.wLocked === true).map(([id])=>id);

    // Si alguien bloqueó W, nunca gana; si bloqueó 8, gana prioritario
    const banned = new Set([...bannedW, ...banned9]);

    let winners=[];
    if(eights.length){
      winners = pickWinners(eights, wanted);
    }else if(sevens.length){
      winners = pickWinners(sevens, wanted);
    }else{
      const allowed = entries.map(([id])=>id).filter(id=>!banned.has(id));
      winners = allowed.length ? pickWinners(allowed, wanted)
                               : pickWinners(entries.map(([id])=>id), wanted);
    }

    const winSet=new Set(winners);

    for(const [id] of fingers){
      const el=dotEls.get(id);
      if(!el) continue;
      el.classList.remove("running");
      el.classList.add(winSet.has(id) ? "win" : "lose");
    }

    const winColors=winners.map(id=>fingers.get(id)?.color).filter(Boolean);
    setFillFromColors(winColors);
    colorFill.classList.add("on");

    // Texto: mismo color que el fondo mientras está el fill
    setHintColorWhenFill(true, winColors[0] || "#000");

    clearTimeout(timer);
    timer=setTimeout(()=>{
      colorFill.classList.remove("on");
      setHintColorWhenFill(false);

      for(const [id] of dotEls){
        if(!winSet.has(id)) removeDot(id);
      }

      state="waiting"; stateEl.textContent="esperando";
      for(const [id] of fingers){
        const el=dotEls.get(id);
        if(el) el.classList.remove("win","lose","running");
      }
      renderLive();
    }, FILL_MS);
  }

  // helper: grabar puntos y bloquear 8/W si se detecta
  function trackAndLockIfNeeded(f){
    if(!f || f.eightLocked || f.wLocked) return;

    f.path.push({x:f.x,y:f.y});

    // prioridad: si detecta 8, bloquea 8 y deja de grabar
    if(isEight(f.path)){
      f.eightLocked = true;
      f.wLocked = false;
      f.path = f.path.slice(-80);
      return;
    }

    // si detecta W, bloquea W y deja de grabar
    if(isW(f.path)){
      f.wLocked = true;
      f.eightLocked = false;
      f.path = f.path.slice(-80);
      return;
    }
  }

  // --- Touch events ---
  zone.addEventListener("touchstart", e=>{
    e.preventDefault();
    let changed=false;

    for(const t of e.changedTouches){
      const id=t.identifier;

      if(!fingers.has(id) && fingers.size < MAX){
        fingers.set(id, {x:t.clientX, y:t.clientY, taps:0, color:null, path:[], eightLocked:false, wLocked:false});
        changed=true;
      }

      const f=fingers.get(id);
      if(f){
        f.x=t.clientX; f.y=t.clientY;

        if(state==="running"){
          f.taps++;
          trackAndLockIfNeeded(f); // ✅ punto inicial + lock live
        }
      }
    }

    if(state==="waiting" && lastCount<2 && fingers.size>=2) startRound();

    if(changed){
      ensureUniqueColorsStable();
      if(state==="running") restartRoundTimer(); // NO resetea 8/W ya hechos
    }

    lastCount=fingers.size;
    if(state!=="fin") renderLive();
  }, {passive:false});

  zone.addEventListener("touchmove", e=>{
    e.preventDefault();
    if(state!=="running") return;

    for(const t of e.changedTouches){
      const f=fingers.get(t.identifier);
      if(!f) continue;

      f.x=t.clientX; f.y=t.clientY;

      // ✅ si ya bloqueó 8 o W, ignorar movimiento
      if(f.eightLocked || f.wLocked) continue;

      trackAndLockIfNeeded(f);
    }
    renderLive();
  }, {passive:false});

  zone.addEventListener("touchend", e=>{
    e.preventDefault();
    let changed=false;

    for(const t of e.changedTouches){
      if(fingers.has(t.identifier)){
        const f=fingers.get(t.identifier);

        // punto final (si no estaba bloqueado)
        if(state==="running" && f && !(f.eightLocked || f.wLocked)){
          trackAndLockIfNeeded(f);
        }

        fingers.delete(t.identifier);
        removeDot(t.identifier);
        changed=true;
      }
    }

    lastCount=fingers.size;

    if(changed && state==="running"){
      ensureUniqueColorsStable();
      restartRoundTimer();
      renderLive();
    }
  }, {passive:false});

  zone.addEventListener("touchcancel", e=>{
    e.preventDefault();
    let changed=false;

    for(const t of e.changedTouches){
      if(fingers.has(t.identifier)){
        const f=fingers.get(t.identifier);
        if(state==="running" && f && !(f.eightLocked || f.wLocked)){
          trackAndLockIfNeeded(f);
        }

        fingers.delete(t.identifier);
        removeDot(t.identifier);
        changed=true;
      }
    }

    lastCount=fingers.size;

    if(changed && state==="running"){
      ensureUniqueColorsStable();
      restartRoundTimer();
      renderLive();
    }
  }, {passive:false});

  // init
  stateEl.textContent="esperando";
  ensureUniqueColorsStable();
  renderLive();
})();
</script>
</body>
</html>
