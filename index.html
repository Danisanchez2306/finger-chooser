<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Finger Chooser</title>

  <style>
    html, body{
      margin:0;
      height:100%;
      background:black;
      font-family:-apple-system,system-ui,sans-serif;
      overflow:hidden;
      color:white;
    }

    #zone{
      height:100%;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
    }

    /* Fondo final (color/degradado) */
    #colorFill{
      position:fixed;
      inset:0;
      opacity:0;
      transition: opacity 220ms ease;
      z-index:1;
      pointer-events:none;
    }
    #colorFill.on{ opacity:1; }

    /* Barra superior */
    #topbar{
      position:fixed;
      top:12px;
      left:12px;
      right:12px;
      z-index:10;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }

    #state{
      font-size:18px;
      opacity:0.95;
      text-transform: lowercase;
    }

    #controls{
      display:flex;
      align-items:center;
      gap:8px;
      background:rgba(255,255,255,.10);
      padding:10px 12px;
      border-radius:16px;
      backdrop-filter: blur(8px);
    }

    #controls label{
      font-size:14px;
      opacity:0.9;
    }

    #winnerCount{
      appearance:none;
      -webkit-appearance:none;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(0,0,0,.35);
      color:white;
      padding:8px 10px;
      border-radius:12px;
      font-size:14px;
      outline:none;
    }

    /* Círculo base */
    .dot{
      --c: #ff3b30;

      position:fixed;
      width:130px;
      height:130px;
      border-radius:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:5;

      box-shadow:0 0 40px rgba(255,255,255,.18);
      opacity:0.96;

      transition:
        opacity 260ms ease,
        transform 260ms ease,
        filter 260ms ease;
    }

    /* ARO exterior estilo Chwazi (segmentado, color sólido) */
    .dot::before{
      content:"";
      position:absolute;
      inset:-14px;
      border-radius:50%;
      background: conic-gradient(
        from 0deg,
        var(--c) 0deg, var(--c) 70deg,
        transparent 70deg, transparent 180deg,
        var(--c) 180deg, var(--c) 250deg,
        transparent 250deg, transparent 360deg
      );
      -webkit-mask: radial-gradient(circle, transparent 58%, #000 60%);
      mask: radial-gradient(circle, transparent 58%, #000 60%);
      transform: rotate(0deg);
      opacity:0.98;
    }

    /* El aro gira SOLO durante la ronda */
    .dot.running::before{
      animation: ringSpin 700ms linear infinite;
    }
    @keyframes ringSpin{ to { transform: rotate(360deg); } }

    /* Perdedor: se desvanece y desaparece */
    .dot.lose{
      opacity:0;
      transform:translate(-50%,-50%) scale(0.78);
      filter: blur(2px) brightness(0.9);
    }

    /* Ganador: estilo “donut negro + anillos” (como tu foto) */
    @keyframes winPop {
      0%   { transform:translate(-50%,-50%) scale(1.25); }
      100% { transform:translate(-50%,-50%) scale(1.05); }
    }

    .dot.win{
      background:#000 !important; /* donut negro */
      box-shadow:none;
      opacity:1;
      animation: winPop 220ms ease-out forwards;
    }

    /* En ganador, quitamos el aro exterior giratorio */
    .dot.win::before{
      content:none;
    }

    /* Anillos internos del ganador (color + negro) */
    .dot.win::after{
      content:"";
      position:absolute;
      inset:30px;              /* ajusta: 28–34 según te guste */
      border-radius:50%;
      box-shadow:
        inset 0 0 0 10px var(--c),
        inset 0 0 0 18px #000;
    }
  </style>
</head>

<body>
  <div id="colorFill"></div>

  <div id="topbar">
    <div id="state">esperando</div>

    <div id="controls">
      <label for="winnerCount">Ganadores</label>
      <select id="winnerCount">
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
      </select>
    </div>
  </div>

  <div id="zone"></div>

<script>
(() => {
  const zone = document.getElementById("zone");
  const stateEl = document.getElementById("state");
  const winnerCountEl = document.getElementById("winnerCount");
  const colorFill = document.getElementById("colorFill");

  const MAX = 5;
  const ROUND_MS = 4000;
  const FILL_MS = 5000;

  // Colores vivos (sin blanco/gris/negro)
  const COLORS = [
    "#ff3b30", "#ff9500", "#ffcc00", "#34c759", "#00c7be",
    "#007aff", "#5856d6", "#af52de", "#ff2d55", "#ff6f00"
  ];

  // id -> {x,y,taps,color}
  const fingers = new Map();
  // id -> element
  const dotEls = new Map();

  let state = "waiting"; // waiting | running | fin
  let timer = null;
  let lastCount = 0;

  const rand = (n) => Math.floor(Math.random() * n);

  const shuffle = (arr) => {
    const a = arr.slice();
    for (let i=a.length-1; i>0; i--){
      const j = rand(i+1);
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  };

  const vibrate = (pattern) => {
    try { if (navigator.vibrate) navigator.vibrate(pattern); } catch(_) {}
  };

  const ensureDot = (id) => {
    let el = dotEls.get(id);
    if (el) return el;
    el = document.createElement("div");
    el.className = "dot";
    document.body.appendChild(el);
    dotEls.set(id, el);
    return el;
  };

  const removeDot = (id) => {
    const el = dotEls.get(id);
    if (el) { el.remove(); dotEls.delete(id); }
  };

  // ✅ Colores únicos SIEMPRE (hasta 5)
  function ensureUniqueColors(){
    const ids = [...fingers.keys()];
    const colors = shuffle(COLORS).slice(0, ids.length);
    for (let i=0; i<ids.length; i++){
      fingers.get(ids[i]).color = colors[i];
    }
  }

  function renderLive(){
    for (const [id, f] of fingers){
      const el = ensureDot(id);

      el.style.left = f.x + "px";
      el.style.top  = f.y + "px";
      el.style.background = f.color || COLORS[0];
      el.style.setProperty("--c", f.color || COLORS[0]);

      el.classList.toggle("running", state === "running");
      el.classList.remove("win","lose");
    }

    for (const [id] of dotEls){
      if (!fingers.has(id)) removeDot(id);
    }
  }

  // ✅ reinicia los 4s cada vez que entra/sale un dedo durante running
  function restartRoundTimer(){
    if (state !== "running") return;
    clearTimeout(timer);
    timer = setTimeout(endRound, ROUND_MS);
  }

  function startRound(){
    if (fingers.size < 2) return;

    state = "running";
    stateEl.textContent = "jugando";

    for (const f of fingers.values()) f.taps = 0;

    ensureUniqueColors();
    renderLive();

    clearTimeout(timer);
    timer = setTimeout(endRound, ROUND_MS);
  }

  function pickWinners(ids, k){
    const pool = ids.slice();
    const out = [];
    const want = Math.min(k, pool.length);
    for (let i=0; i<want; i++){
      const idx = rand(pool.length);
      out.push(pool[idx]);
      pool.splice(idx, 1);
    }
    return out;
  }

  function setFillFromWinnerColors(colors){
    if (colors.length <= 1){
      colorFill.style.background = colors[0] || "black";
    } else {
      const stops = colors.map((c,i)=>{
        const p = Math.round((i/(colors.length-1))*100);
        return `${c} ${p}%`;
      }).join(", ");
      colorFill.style.background = `linear-gradient(135deg, ${stops})`;
    }
  }

  function endRound(){
    state = "fin";
    stateEl.textContent = "fin";

    const entries = [...fingers.entries()];
    const wanted = parseInt(winnerCountEl.value || "1", 10);

    // reglas 7/9 mantienen su lógica
    const seven   = entries.filter(([_,f]) => f.taps === 7).map(([id]) => id);
    const allowed = entries.filter(([_,f]) => f.taps !== 9).map(([id]) => id);

    let winners = [];
    if (seven.length > 0){
      winners = pickWinners(seven, wanted);
      if (winners.length < wanted){
        const rest = allowed.filter(id => !winners.includes(id));
        winners = winners.concat(pickWinners(rest, wanted - winners.length));
      }
    } else {
      if (allowed.length > 0) winners = pickWinners(allowed, wanted);
      else if (entries.length > 0) winners = pickWinners(entries.map(([id])=>id), wanted);
    }

    const winSet = new Set(winners);

    // vibración al decidir
    vibrate([30, 40, 30, 40, 60]);

    // ganadores: donut negro + anillos internos
    // perdedores: desaparecen
    for (const [id] of fingers){
      const el = dotEls.get(id);
      if (!el) continue;
      el.classList.remove("running");
      if (winSet.has(id)) el.classList.add("win");
      else el.classList.add("lose");
    }

    // fondo color/degradado 5s
    const winColors = winners.map(id => fingers.get(id)?.color).filter(Boolean);
    setFillFromWinnerColors(winColors);
    colorFill.classList.add("on");

    clearTimeout(timer);
    timer = setTimeout(() => {
      colorFill.classList.remove("on");

      // eliminar perdedores del DOM (ya invisibles)
      for (const [id] of dotEls){
        if (!winSet.has(id)) removeDot(id);
      }

      state = "waiting";
      stateEl.textContent = "esperando";

      // limpiar clases de los que queden
      for (const [id] of fingers){
        const el = dotEls.get(id);
        if (el) el.classList.remove("win","lose","running");
      }

      renderLive();
    }, FILL_MS);
  }

  // --- Eventos táctiles ---
  zone.addEventListener("touchstart", (e) => {
    e.preventDefault();

    let changedCount = false;

    for (const t of e.changedTouches){
      const id = t.identifier;

      // admitir dedo nuevo si hay hueco
      if (!fingers.has(id) && fingers.size < MAX){
        fingers.set(id, { x:t.clientX, y:t.clientY, taps:0, color:null });
        changedCount = true;
      }

      // update pos / contar taps
      const f = fingers.get(id);
      if (f){
        f.x = t.clientX;
        f.y = t.clientY;
        if (state === "running") f.taps++;
      }
    }

    if (changedCount){
      ensureUniqueColors();
      if (state === "running") restartRoundTimer();
    }

    // empieza al llegar a 2 dedos
    if (state === "waiting" && lastCount < 2 && fingers.size >= 2){
      startRound();
    }

    lastCount = fingers.size;

    if (state !== "fin") renderLive();
  }, { passive:false });

  zone.addEventListener("touchmove", (e) => {
    e.preventDefault();
    if (state === "fin") return;

    for (const t of e.changedTouches){
      const f = fingers.get(t.identifier);
      if (f){
        f.x = t.clientX;
        f.y = t.clientY;
      }
    }
    renderLive();
  }, { passive:false });

  zone.addEventListener("touchend", (e) => {
    e.preventDefault();

    let changedCount = false;

    for (const t of e.changedTouches){
      if (fingers.has(t.identifier)){
        fingers.delete(t.identifier);
        removeDot(t.identifier);
        changedCount = true;
      }
    }

    lastCount = fingers.size;

    // reiniciar 4s si estamos jugando y alguien salió
    if (changedCount && state === "running"){
      ensureUniqueColors();
      restartRoundTimer();
      renderLive();
    }
  }, { passive:false });

  zone.addEventListener("touchcancel", (e) => {
    e.preventDefault();

    let changedCount = false;

    for (const t of e.changedTouches){
      if (fingers.has(t.identifier)){
        fingers.delete(t.identifier);
        removeDot(t.identifier);
        changedCount = true;
      }
    }

    lastCount = fingers.size;

    if (changedCount && state === "running"){
      ensureUniqueColors();
      restartRoundTimer();
      renderLive();
    }
  }, { passive:false });

  // init
  stateEl.textContent = "esperando";
  ensureUniqueColors();
  renderLive();
})();
</script>
</body>
</html>
