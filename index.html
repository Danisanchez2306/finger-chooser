<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Finger Chooser</title>

<style>
:root{ --green:#7fb13a; --orange:#ff8a00; }
html,body{ margin:0;height:100%;background:#000;overflow:hidden;font-family:-apple-system,system-ui,sans-serif; }
#zone{ height:100%; touch-action:none; user-select:none; -webkit-user-select:none; }

#colorFill{
  position:fixed; inset:0; opacity:0; transition:opacity .22s;
  z-index:1; pointer-events:none;
}
#colorFill.on{ opacity:1; }

#topbar{
  position:fixed; top:12px; left:12px; right:12px; z-index:10;
  display:flex; justify-content:space-between; align-items:flex-start; gap:12px;
}
#winBtn,#helpBtn{
  width:76px;height:76px;border-radius:50%;
  display:flex;align-items:center;justify-content:center;
  color:#fff;font-weight:500;
  border:none;outline:none;
  box-shadow:0 6px 18px rgba(0,0,0,.35);
  -webkit-tap-highlight-color:transparent;
}
#winBtn{ background:var(--green); font-size:34px; }
#helpBtn{ background:#ff00a8; font-size:44px; }

#hint{
  position:fixed; right:10px; bottom:10px; font-size:11px;
  color:#000; opacity:.6; z-index:20; user-select:none; pointer-events:none;
}
#state{
  position:fixed; left:50%; top:16px; transform:translateX(-50%);
  font-size:13px; opacity:.55; text-transform:lowercase; z-index:10;
  color:#000; pointer-events:none;
}

/* Modal */
#modalOverlay{
  position:fixed; inset:0; z-index:50;
  display:none; align-items:center; justify-content:center;
  background:rgba(0,0,0,.15);
}
#modalOverlay.on{display:flex;}
#modal{
  width:min(340px,86vw);
  background:#fff; border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.35);
  padding:16px 16px 14px; color:#1a1a1a;
}
#row{ display:flex; align-items:center; justify-content:space-between; padding:4px 6px 14px; }
.stepBtn{
  width:54px;height:54px;border-radius:50%;
  border:3px solid var(--accent);
  background:#fff;color:var(--accent);
  font-size:34px;line-height:0;
  display:flex;align-items:center;justify-content:center;
  -webkit-tap-highlight-color:transparent;
}
#count{ font-size:44px; font-weight:500; color:#4a4a4a; }
#seg{
  width:100%;
  border:2px solid var(--accent);
  border-radius:14px; overflow:hidden; display:flex;
}
.segBtn{
  flex:1; padding:10px 0; font-size:18px;
  border:none; outline:none; background:#fff; color:var(--accent);
}
.segBtn.active{ background:var(--accent); color:#fff; }

/* =========================
   DOT + AROS (animación)
   ========================= */
.dot{
  --c:#ff3b30;
  --fill:#ff3b30;
  position:fixed;
  width:130px;height:130px;border-radius:50%;
  transform:translate(-50%,-50%);
  pointer-events:none;
  z-index:5;
  background:var(--fill);
  box-shadow:0 0 36px rgba(255,255,255,.14);
  transition:opacity .18s, transform .18s, filter .18s;
}

.dot::before{
  content:"";
  position:absolute; inset:-16px; border-radius:50%;
  background:conic-gradient(
    from 0deg,
    var(--c) 0 70deg,
    transparent 70deg 175deg,
    var(--c) 175deg 255deg,
    transparent 255deg 360deg
  );
  -webkit-mask:radial-gradient(circle,transparent 60%,#000 61%);
  mask:radial-gradient(circle,transparent 60%,#000 61%);
  opacity:.92;
  transform:rotate(0deg);
}

.dot::after{
  content:"";
  position:absolute; inset:-8px; border-radius:50%;
  background:conic-gradient(
    from 25deg,
    transparent 0 45deg,
    var(--c) 45deg 100deg,
    transparent 100deg 220deg,
    var(--c) 220deg 270deg,
    transparent 270deg 360deg
  );
  -webkit-mask:radial-gradient(circle,transparent 68%,#000 69%);
  mask:radial-gradient(circle,transparent 68%,#000 69%);
  opacity:.62;
  transform:rotate(0deg);
}

.dot.running::before{ animation:ringSpin .65s linear infinite, ringBreathe .9s ease-in-out infinite; }
.dot.running::after { animation:ringSpinReverse .72s linear infinite, ringBreathe2 .95s ease-in-out infinite; }

@keyframes ringSpin{ to{ transform:rotate(360deg); } }
@keyframes ringSpinReverse{ to{ transform:rotate(-360deg); } }
@keyframes ringBreathe{ 0%,100%{ filter:brightness(1); } 50%{ filter:brightness(1.12); } }
@keyframes ringBreathe2{ 0%,100%{ opacity:.45; } 50%{ opacity:.75; } }

/* ganador: negro + aro color */
@keyframes winPop{
  0%{transform:translate(-50%,-50%) scale(1.18)}
  100%{transform:translate(-50%,-50%) scale(1.05)}
}
.dot.win{
  background:#000 !important;
  box-shadow:none;
  opacity:1;
  animation:winPop .22s ease-out forwards;
}
.dot.win::before{ opacity:0; }
.dot.win::after{
  opacity:1;
  -webkit-mask:none; mask:none;
  background:transparent;
  inset:0; border-radius:50%;
  box-shadow: inset 0 0 0 10px var(--c), inset 0 0 0 18px #000;
}
</style>
</head>

<body>
<div id="colorFill"></div>

<div id="topbar">
  <button id="winBtn" aria-label="Ganadores">1F</button>
  <button id="helpBtn" aria-label="Ayuda">?</button>
</div>

<div id="state">esperando</div>
<div id="hint">8 gana · W pierde · 7 gana · 9 pierde</div>

<div id="modalOverlay" role="dialog" aria-modal="true">
  <div id="modal">
    <div id="row">
      <button class="stepBtn" id="minus" aria-label="Menos">−</button>
      <div id="count">1</div>
      <button class="stepBtn" id="plus" aria-label="Más">+</button>
    </div>
    <div id="seg">
      <button class="segBtn active" id="segFingers">Fingers</button>
      <button class="segBtn" id="segGroups">Groups</button>
    </div>
  </div>
</div>

<div id="zone"></div>

<script>
(() => {
  const zone = document.getElementById("zone");
  const colorFill = document.getElementById("colorFill");
  const hintEl = document.getElementById("hint");
  const stateEl = document.getElementById("state");

  const winBtn = document.getElementById("winBtn");
  const helpBtn = document.getElementById("helpBtn");
  const overlay = document.getElementById("modalOverlay");
  const minusBtn = document.getElementById("minus");
  const plusBtn = document.getElementById("plus");
  const countEl = document.getElementById("count");
  const segFingers = document.getElementById("segFingers");
  const segGroups = document.getElementById("segGroups");
  const modal = document.getElementById("modal");

  const MAX = 5;
  const ROUND_MS = 4000;
  const HOLD_MS = 5000;

  // ✅ SOLO CAMBIO: 10 colores fosforitos, bien contrastados
  const COLORS = [
    "#00FF00", // verde neón
    "#00FFFF", // cian neón
    "#1E90FF", // azul eléctrico
    "#FFD700", // amarillo neón
    "#FF0000", // rojo puro
    "#FF8C00", // naranja neón
    "#ADFF2F", // lima
    "#FF1493", // rosa neón
    "#7CFF00", // verde ácido
    "#8A2BE2"  // violeta eléctrico (separado del rosa)
  ];

  let selectorValue = 1;
  let mode = "fingers";

  const fingers = new Map();
  const dots = new Map();

  // waiting | running | winnerLive | groupsLive | postHold
  let state = "waiting";
  let roundTimer = null;
  let holdTimer = null;

  let winnersSet = new Set();
  let winnerColors = [];

  // [{x,y, fill, ring, isWin}]
  let holdSnapshot = [];

  const rand = n => Math.floor(Math.random()*n);
  const shuffle = a => { a=a.slice(); for(let i=a.length-1;i;i--){ const j=rand(i+1); [a[i],a[j]]=[a[j],a[i]]; } return a; };

  function setAccent(){
    const accent = (mode==="groups")
      ? getComputedStyle(document.documentElement).getPropertyValue("--orange").trim()
      : getComputedStyle(document.documentElement).getPropertyValue("--green").trim();
    modal.style.setProperty("--accent", accent);
    winBtn.style.background = (mode==="groups") ? "var(--orange)" : "var(--green)";
  }

  function setHiddenTextColor(color){
    hintEl.style.color = color;
    stateEl.style.color = color;
  }

  // Si hay degradado (2+ ganadores), texto transparente (invisible)
  function setSecretTextForWinnerBackground(colors){
    if(!colors || colors.length === 0){
      setHiddenTextColor("#000");
      return;
    }
    if(colors.length > 1){
      setHiddenTextColor("transparent");
      return;
    }
    setHiddenTextColor(colors[0] || "#000");
  }

  function ensureDot(key){
    if(dots.has(key)) return dots.get(key);
    const d = document.createElement("div");
    d.className = "dot";
    document.body.appendChild(d);
    dots.set(key, d);
    return d;
  }
  function removeDot(key){
    const el = dots.get(key);
    if(el){ el.remove(); dots.delete(key); }
  }
  function clearAllDots(){
    for(const [k] of dots) removeDot(k);
  }

  function mixWithWhite(hex, t){
    const h = hex.replace("#","");
    const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
    const rr = Math.round(r + (255-r)*t);
    const gg = Math.round(g + (255-g)*t);
    const bb = Math.round(b + (255-b)*t);
    return "#" + [rr,gg,bb].map(x=>x.toString(16).padStart(2,"0")).join("");
  }

  function ensureUniqueRealColors(){
    const used = new Set();
    for(const f of fingers.values()) if(f.realColor) used.add(f.realColor);
    const available = shuffle(COLORS.filter(c => !used.has(c)));
    for(const f of fingers.values()){
      if(!f.realColor){
        f.realColor = available.length ? available.pop() : COLORS[rand(COLORS.length)];
        used.add(f.realColor);
      }
    }
  }

  function setFillFromWinnerColors(colors){
    const cs = (colors || []).filter(Boolean);
    if(cs.length <= 1){
      colorFill.style.background = cs[0] || "#000";
    } else {
      const stops = cs.map((c,i)=>`${c} ${Math.round(i/(cs.length-1)*100)}%`).join(", ");
      colorFill.style.background = `linear-gradient(135deg, ${stops})`;
    }
  }

  function clearTimers(){
    clearTimeout(roundTimer); roundTimer=null;
    clearTimeout(holdTimer); holdTimer=null;
  }

  function goWaitingHard(){
    clearTimers();
    winnersSet = new Set();
    winnerColors = [];
    holdSnapshot = [];
    colorFill.classList.remove("on");
    setHiddenTextColor("#000");
    state = "waiting";
    stateEl.textContent = "esperando";
    fingers.clear();
    clearAllDots();
  }

  function startRound(){
    if(fingers.size < 2) return;
    clearTimers();
    state = "running";
    stateEl.textContent = "jugando";

    for(const f of fingers.values()){
      f.path = [];
      f.eightLocked = false;
      f.wLocked = false;
      f.groupColor = null;
    }

    ensureUniqueRealColors();
    render();

    roundTimer = setTimeout(endRound, ROUND_MS);
  }

  function restartRoundTimer(){
    if(state !== "running") return;
    clearTimeout(roundTimer);
    roundTimer = setTimeout(endRound, ROUND_MS);
  }

  /* ===== 8 / W permisivo ===== */
  function isEight(path){
    if(path.length < 8) return false;
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of path){
      minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
      minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
    }
    if(Math.max(maxX-minX, maxY-minY) < 40) return false;
    let turns=0;
    for(let i=2;i<path.length;i++){
      const a = path[i-2].y - path[i-1].y;
      const b = path[i-1].y - path[i].y;
      if(a*b < 0) turns++;
    }
    return turns >= 3;
  }
  function isW(path){
    if(path.length < 6) return false;
    let changes=0;
    for(let i=2;i<path.length;i++){
      const a = path[i-2].y - path[i-1].y;
      const b = path[i-1].y - path[i].y;
      if(a*b < 0) changes++;
    }
    return changes >= 2;
  }
  function trackAndLockIfNeeded(f){
    if(!f || f.eightLocked || f.wLocked) return;
    f.path.push({x:f.x,y:f.y});
    if(f.path.length > 90) f.path.shift();
    if(isEight(f.path)){ f.eightLocked=true; f.wLocked=false; return; }
    if(isW(f.path)){ f.wLocked=true; f.eightLocked=false; return; }
  }

  function pickWinners(ids, k){
    const pool = ids.slice();
    const out = [];
    const want = Math.min(k, pool.length);
    for(let i=0;i<want;i++){
      const idx = rand(pool.length);
      out.push(pool[idx]);
      pool.splice(idx,1);
    }
    return out;
  }

  function assignGroupsColors(groupCount){
    const ids = [...fingers.keys()];
    const g = Math.max(1, Math.min(4, groupCount));
    const groupColors = shuffle(COLORS).slice(0, g);
    const shuffledIds = shuffle(ids);

    let gi = 0;
    for(const id of shuffledIds){
      const f = fingers.get(id);
      if(!f) continue;
      f.groupColor = groupColors[gi];
      gi = (gi + 1) % g;
    }
  }

  function endRound(){
    clearTimeout(roundTimer);

    if(mode === "groups"){
      assignGroupsColors(selectorValue);
      state = "groupsLive";
      stateEl.textContent = "grupos";
      colorFill.classList.remove("on");
      setHiddenTextColor("#000");
      render();
      return;
    }

    const entries = [...fingers.entries()];
    const idsAll = entries.map(([id])=>id);

    const eightIds = entries.filter(([_,f])=>f.eightLocked).map(([id])=>id);
    const bannedW = new Set(entries.filter(([_,f])=>f.wLocked).map(([id])=>id));

    let winners = [];
    const wanted = selectorValue;

    if(eightIds.length){
      winners = pickWinners(eightIds, wanted);
    } else {
      const allowed = idsAll.filter(id => !bannedW.has(id));
      winners = allowed.length ? pickWinners(allowed, wanted) : pickWinners(idsAll, wanted);
    }

    winnersSet = new Set(winners);
    winnerColors = winners.map(id => fingers.get(id)?.realColor).filter(Boolean);

    setFillFromWinnerColors(winnerColors);
    colorFill.classList.add("on");
    setSecretTextForWinnerBackground(winnerColors);

    state = "winnerLive";
    stateEl.textContent = "fin";
    render();
  }

  function buildHoldSnapshot(){
    holdSnapshot = [];

    if(state === "winnerLive"){
      for(const id of winnersSet){
        const f = fingers.get(id);
        if(!f) continue;
        const c = f.realColor || winnerColors[0] || "#fff";
        holdSnapshot.push({ x:f.x, y:f.y, fill:"#000", ring:c, isWin:true });
      }
      return;
    }

    if(state === "groupsLive"){
      for(const [id,f] of fingers){
        const gc = f.groupColor || "#e8e8e8";
        holdSnapshot.push({ x:f.x, y:f.y, fill:gc, ring:mixWithWhite(gc,0.25), isWin:false });
      }
      return;
    }
  }

  function enterPostHoldAndReset(){
    buildHoldSnapshot();
    fingers.clear();
    clearTimeout(holdTimer);

    state = "postHold";
    stateEl.textContent = "esperando";

    for(const [,el] of dots) el.classList.remove("running");
    render();

    holdTimer = setTimeout(() => {
      goWaitingHard();
    }, HOLD_MS);
  }

  function render(){
    if(state === "postHold"){
      clearAllDots();
      for(let i=0;i<holdSnapshot.length;i++){
        const s = holdSnapshot[i];
        const key = "H"+i;
        const el = ensureDot(key);
        el.style.left = s.x+"px";
        el.style.top  = s.y+"px";
        el.style.setProperty("--fill", s.fill);
        el.style.setProperty("--c", s.ring);
        el.classList.remove("running");
        if(s.isWin) el.classList.add("win");
        else el.classList.remove("win");
      }
      return;
    }

    if(state === "waiting" || state === "running"){
      for(const [id,f] of fingers){
        const el = ensureDot(id);
        el.style.left = f.x+"px";
        el.style.top  = f.y+"px";

        if(mode === "groups" && state === "running"){
          el.style.setProperty("--fill", "#e8e8e8");
          el.style.setProperty("--c", "#bdbdbd");
        } else {
          const c = f.realColor || COLORS[0];
          el.style.setProperty("--fill", c);
          el.style.setProperty("--c", c);
        }

        el.classList.toggle("running", state==="running");
        el.classList.remove("win");
      }
      for(const [k] of dots){
        if(!fingers.has(k)) removeDot(k);
      }
      return;
    }

    if(state === "winnerLive"){
      for(const [k] of dots){
        if(!winnersSet.has(k)) removeDot(k);
      }
      for(const [id,f] of fingers){
        if(!winnersSet.has(id)){
          removeDot(id);
          continue;
        }
        const el = ensureDot(id);
        el.style.left = f.x+"px";
        el.style.top  = f.y+"px";
        const c = f.realColor || winnerColors[0] || "#fff";
        el.style.setProperty("--fill", c);
        el.style.setProperty("--c", c);
        el.classList.add("win","running");
      }
      return;
    }

    if(state === "groupsLive"){
      for(const [id,f] of fingers){
        const el = ensureDot(id);
        el.style.left = f.x+"px";
        el.style.top  = f.y+"px";
        const gc = f.groupColor || "#e8e8e8";
        el.style.setProperty("--fill", gc);
        el.style.setProperty("--c", mixWithWhite(gc, 0.25));
        el.classList.add("running");
        el.classList.remove("win");
      }
      for(const [k] of dots){
        if(!fingers.has(k)) removeDot(k);
      }
      return;
    }
  }

  /* =========================
     TOUCH
     ========================= */
  function canAddNewFingers(){
    return (state === "waiting" || state === "running");
  }

  zone.addEventListener("touchstart", e => {
    e.preventDefault();
    if(!canAddNewFingers()) return;

    let changed = false;
    for(const t of e.changedTouches){
      const id = t.identifier;
      if(!fingers.has(id)){
        if(fingers.size >= MAX) continue;
        fingers.set(id,{
          x:t.clientX, y:t.clientY,
          realColor:null,
          path:[],
          eightLocked:false,
          wLocked:false,
          groupColor:null
        });
        changed = true;
      }
      const f = fingers.get(id);
      if(f){ f.x=t.clientX; f.y=t.clientY; }
    }

    ensureUniqueRealColors();

    if(state==="waiting" && fingers.size>=2){
      startRound();
      return;
    }
    if(state==="running" && changed){
      restartRoundTimer();
    }
    render();
  }, {passive:false});

  zone.addEventListener("touchmove", e => {
    e.preventDefault();
    if(state==="postHold") return;

    for(const t of e.changedTouches){
      const f = fingers.get(t.identifier);
      if(!f) continue;
      f.x=t.clientX; f.y=t.clientY;

      if(state==="running" && mode==="fingers"){
        trackAndLockIfNeeded(f);
      }

      const el = ensureDot(t.identifier);
      el.style.left = f.x+"px";
      el.style.top  = f.y+"px";

      if(state==="running"){
        if(mode==="groups"){
          el.style.setProperty("--fill", "#e8e8e8");
          el.style.setProperty("--c", "#bdbdbd");
          el.classList.add("running");
          el.classList.remove("win");
        } else {
          const c = f.realColor || COLORS[0];
          el.style.setProperty("--fill", c);
          el.style.setProperty("--c", c);
          el.classList.add("running");
          el.classList.remove("win");
        }
      } else if(state==="winnerLive"){
        if(winnersSet.has(t.identifier)){
          const c = f.realColor || winnerColors[0] || "#fff";
          el.style.setProperty("--fill", c);
          el.style.setProperty("--c", c);
          el.classList.add("win","running");
        } else {
          removeDot(t.identifier);
        }
      } else if(state==="groupsLive"){
        const gc = f.groupColor || "#e8e8e8";
        el.style.setProperty("--fill", gc);
        el.style.setProperty("--c", mixWithWhite(gc, 0.25));
        el.classList.add("running");
        el.classList.remove("win");
      }
    }
  }, {passive:false});

  function handleEndLike(e){
    e.preventDefault();

    for(const t of e.changedTouches){
      const id = t.identifier;
      const f = fingers.get(id);
      if(f){
        f.x = t.clientX;
        f.y = t.clientY;
      }
      if(fingers.has(id)){
        fingers.delete(id);
        removeDot(id);
      }
    }

    if(state==="running"){
      restartRoundTimer();
    }

    if((state==="winnerLive" || state==="groupsLive") && fingers.size===0){
      for(const [,el] of dots) el.classList.remove("running");
      enterPostHoldAndReset();
      return;
    }

    render();
  }

  zone.addEventListener("touchend", handleEndLike, {passive:false});
  zone.addEventListener("touchcancel", handleEndLike, {passive:false});

  /* =========================
     Modal
     ========================= */
  function updateUI(){
    countEl.textContent = String(selectorValue);
    winBtn.textContent = String(selectorValue) + "F";
    setAccent();
  }
  function openModal(){ overlay.classList.add("on"); }
  function closeModal(){ overlay.classList.remove("on"); }

  winBtn.addEventListener("click",(e)=>{ e.preventDefault(); openModal(); });
  helpBtn.addEventListener("click",(e)=>{ e.preventDefault(); openModal(); });
  overlay.addEventListener("click",(e)=>{ if(e.target===overlay) closeModal(); });

  minusBtn.addEventListener("click",(e)=>{ e.preventDefault(); selectorValue=Math.max(1, selectorValue-1); updateUI(); });
  plusBtn.addEventListener("click",(e)=>{ e.preventDefault(); selectorValue=Math.min(4, selectorValue+1); updateUI(); });

  segFingers.addEventListener("click",(e)=>{
    e.preventDefault();
    mode="fingers";
    segFingers.classList.add("active");
    segGroups.classList.remove("active");
    updateUI();
  });
  segGroups.addEventListener("click",(e)=>{
    e.preventDefault();
    mode="groups";
    segGroups.classList.add("active");
    segFingers.classList.remove("active");
    updateUI();
  });

  // init
  stateEl.textContent="esperando";
  setHiddenTextColor("#000");
  updateUI();
})();
</script>
</body>
</html>
